
%       Copyright (c) 2001-2019 by INRIA and SDTools, All Rights Reserved.
%       Use under OpenFEM trademark.html license and LGPL.txt library license
%       $Revision: 1.273 $  $Date: 2021/11/05 08:19:04 $

%------------------------------------------------------------------------
%------------------------------------------------------------------------
%------------------------------------------------------------------------
\Tchapter{Developer information}{dstruct}

This chapter gives a detailed description of the formats used for variables and data structures. This information is grouped here and hypertext reference is given in the HTML version of the manual.


%----------------------------------------------------------------------------
\csection{Nodes}{node}%
\index{NodeId}\index{node}\index{node!group}\index{coordinate}

\subsection{Node matrix}


\noindent {\sl Nodes} are characterized using the convention of Universal files.  {\tt model.Node} and {\tt FEnode} are node matrices. A node matrix has seven columns.  Each row of gives

\begin{verbatim}
 NodeId PID DID GID x y z 
\end{verbatim}

\noindent where {\tt NodeId} are node numbers (positive integers with no constraint on order or continuity), {\tt PID}\index{PID} and {\tt DID}\index{DID} are coordinate system numbers for position and displacement respectively (zero or any positive integer), {\tt GID}\index{GID} is a node group number 
(zero or any positive integer), and {\tt x y z} are the coordinates . For cylindrical coordinate systems, coordinates represent {\tt r teta z} (radius, angle in degrees, and z axis value). For spherical coordinates systems, they represent {\tt r teta phi} (radius, angle from vertical axis in degrees, azimuth in degrees). For local coordinate system support see~\ser{febas}.


\vs A simple line of 10 nodes along the $x$ axis could be simply generated by the command

\begin{verbatim}
 node = [[1:10]' zeros(10,3) linspace(0,1,10)'*[1 0 0]]; 
\end{verbatim}

For other examples take a look at the finite element related demonstrations (see \ser{fem}) and the mesh handling utility \femesh.

\lvs The {\bf only restriction} applied to the {\tt NodeId} is that they should be positive integers. The earlier limit of {\tt round((2\verb+^+31-1)/100) $\approx$ 21e6} is no longer applicable. 

In many cases, you will want to access particular nodes by their number. The standard approach is to create a reindexing vector called {\tt NNode}. Thus the commands

\begin{verbatim}
 NNode=[];NNode(node(:,1))=1:size(node,1);
 Indices_of_Nodes = NNode(List_of_NodeId) 
\end{verbatim}

\noindent gives you a simple mechanism to determine the indices in the {\tt node} matrix of a set of nodes with identifiers {\tt List\_of\_NodeId}. The \hyperlink{findnode}{{\tt feutil \ts{FindNode}}} commands provide tools for more complex selection of nodes in a large list.\index{node!selection}

%-----------------------------------------------------------------------
%-----------------------------------------------------------------------
\csssection{Coordinate system handling}{febas}

Local coordinate systems are stored in a {\tt model.bas} field (see \ltt{NodeBas}). Columns 2 and 3 of \hyperlink{node}{{\tt model.Node}} define respectively coordinate system numbers for position and displacement. 

\begin{SDT}
Use of local coordinate systems is illustrated in~\ser{corcoor} where a local basis is defined for test results.
\end{SDT}

\feplot, \femk, \rigid, ... now support local coordinates. \feutil\ does when the model is described by a data structure with the {\tt .bas} field. \femesh\ assumes you are using global coordinate system obtained with

\begin{verbatim}
 [FEnode,bas] = basis(model.Node,model.bas)
\end{verbatim}

To write your own scripts using local coordinate systems, it is useful to know the following calls:

{\tt [node,bas,NNode]=feutil('getnodebas',model)} returns the nodes in global coordinate system, the bases {\tt bas} with recursive definitions resolved and the reindexing vector {\tt NNode}. 

To obtain, the local to global transformation matrix (meaning $\ve{q_{global}} = \ma{c_{GL}} \ve{q_{local}}$) use
\begin{verbatim}
 cGL=basis('trans l',model.bas,model.Node,model.DOF)
\end{verbatim}


%--------------------------------------------------------------------------
\csection{Model description matrices}{elt}%

\noindent A {\sl model description matrix} describes the model elements. {\tt model.Elt} and {\tt FEelt} are, for example, model description matrices. The declaration of a finite element model is done through the use of element groups stacked as rows of a model description matrix {\tt elt} and separated by header rows whose first element is {\tt Inf} in Matlab or {\tt \%inf} in Scilab and the following are the {\sc ascii} values for the name of the element. In the following, Matlab notation is used. Don't forget to replace {\tt Inf} by {\tt \%inf} in Scilab. \\
For example a model described by \index{model!description matrix}\index{element!group}\index{element!function}

\begin{verbatim}
 elt = [Inf abs('beam1')                 0 0
          1  2  11  12  5              0 0 0
          2  3  11  12  5              0 0 0
        Inf abs('mass1')               0 102
          2  1e2 1e2 1e2  5e-5 5e-5 5e-5   0 ];
\end{verbatim}

\noindent has 2 groups. The first group contains 2 \beam\ elements between nodes 1-2 and 2-3 with material property 11, section property 12, and bending plane containing node 5. The second group contains a concentrated mass on node 2.

Note how columns unused for a given type element are filled with zeros. The {\tt 102} declared for the mass corresponds to an element group identification number {\tt EGID}\index{EGID}\index{element!EGID}. 

You can find more realistic examples of model description matrices in the demonstrations (see \ser{fem}).


\lvs\noindent\fbox{The general format for {\bf header rows} is}

\lvs{\tt [Inf abs('{\ti ElementName}') 0 {\ti opt} ]}

\noindent The {\tt Inf} that mark the element row and the {\tt 0} that mark the end of the element name are {\bf required} (the {\tt 0} may only be omitted if the name ends with the last column of {\tt elt}).

For multi-platform compatibility, {\bf element names} should only contain lower case letters and numbers.  In any case never include blanks, slashes, ... in the element name.  Element names reserved for supported elements are listed in the element reference chapter~\ref{s*eltfun} \begin{SDT} (or {\tt doc('eltfun')} from the command line) \end{SDT}.


Users can define new elements by creating functions (\ts{.m} or \ts{.mex} in Matlab, \ts{.sci} in Scilab) files with the element name.  Specifications on how to create element functions are given in~\ser{elem0}. 

\lvs Element group options {\ti opt} can follow the zero that marks the end of the element name. {\tt opt(1)}, if used, should be the element group identification number \htt{EGID}.  In the example, the group of \mass\ elements is this associated to the {\ti EGID} 102.  
The default element group identification number is its order in the group declaration.  Negative {\tt EGID} are ignored in FEM analyzes (display only, test information, ...).

Between group headers, each row describes an element of the type corresponding to the previous header (first header row above the considered row).

\lvs\noindent\fbox{The general format for {\bf element rows} is}%
\index{element!property row} %  - - - - - - - - - - - - - - - - - -

\begin{verbatim}
 [NodeNumbers MatId ProId EltId OtherInfo]
\end{verbatim}

\noindent where

\begin{Eitem}
\item {\tt NodeNumbers} are positive integers which must match a unique {\tt NodeId} identifier in the first column of the node matrix.

\item \index{MatId}\index{ProId}\htt{MatId} and \htt{ProId} are material and element property identification numbers. They should be positive integers matching a unique identifier in the first column of the material {\tt pl} and element {\tt il} property declaration matrices.

\item \index{EltId}\htt{EltId} are positive integers uniquely identifying each element. See \ltr{feutil}{EltId} for a way to return the vector and verify/fix identifiers.


\item{\tt OtherInfo} can for example be the node number of a reference node (\beam\ element). These columns can be used to store arbitrary element dependent information. Typical applications would be node dependent plate thickness, offsets, etc.


\end{Eitem}

 Note that the position of {\tt MatId}, {\tt ProId} and {\tt EltId} in the element rows are returned by calls of the form {\tt ind=elem0('prop')} ({\tt elem0} is a generic element name, it can be {\tt bar1}, {\tt hexa8}, \ldots).

\noindent Element property rows are used for assembly by \femk, display by \feplot, model building by \femesh, ...


%------------------------------------------------------------------------------
\csection{Material property matrices and stack entries}{pl}\index{pl}\index{material properties}\index{MatId}\index{material function}

This section describes the low level format for material properties. The actual formats are described under {\tt m\_} functions \melastic, {\tt m\_piezo}, ... For \begin{SDT} Graphical edition and \end{SDT} standard scripts see \ser{femp}.

A material is normally defined as a row in the {\sl material property matrix} {\tt pl}. Such rows give a declaration of the general form {\tt [MatId Type Prop]} with

\vs\noindent\begin{tabular}{@{}p{.15\textwidth}@{}p{.85\textwidth}@{}}
%
\rz{\tt MatId} & a positive integer identifying a particular material property. \\
\rz{\tt Type}  & a positive real number built using calls of the form \femat{\tt ('m\_elastic','SI',subtype)}, the {\tt subtype} integer is described in {\tt m\_} functions. \\
\rz{\tt Prop}  & as many properties (real numbers) as needed (see \femat, \melastic\ for details).
%
\end{tabular}

Additional information can be stored as an entry of type {\tt 'mat'} in the model stack which has data stored in a structure with at least fields
\index{data structure!material}

\vs\noindent\begin{tabular}{@{}p{.15\textwidth}@{}p{.85\textwidth}@{}}
%
\rz{\tt .name} & Description of material. \\
\rz{\tt .pl}   & a single value giving the {\tt MatId} of the corresponding row in the {\tt model.pl} matrix or row of values. \\
& Resolution of the true {\tt .pl} value is done by {\tt pl=fe\_mat('getpl',model)}. The property value in {\tt .pl} should be {\tt -1} for interpolation in {\tt GetPl}, {\tt -2} for interpolation using the table at each integration point, {\tt -3} for direct use of a {\tt FieldAtNode} value as constitutive value.\\
\rz{\tt .unit} & a two character string describing the unit system (see \ltr{fe\_mat}{Convert} and \ts{Unit} commands).\\
\rz{\tt .type} & the name of the material function handling this particular type of material (for example \melastic).\\
\rz{\ti .field} & can be a structure allowing the interpolation of a value called {\ti field} based on the given table. Thus \par {\tt mat.E=struct('X',[-10;20],'Xlab',\{\{'T'\}\},'Y',[10 20]*1e6)} will interpolate value $E$ based on field {\tt T}. The positions of interpolated variables within the {\tt pl} row are given by {\tt list=feval(mat.type, 'propertyunittype cell', subtype)}. 
%
\end{tabular}



%---------------------------------------------------------------------------
\csection{Element property matrices and stack entries}{il}\index{ProId}\index{il}\index{property function}


This section describes the low level format for element properties. The actual formats are described under {\tt p\_} functions \pshell, \psolid, \pbeam, \pspring. For \begin{SDT}Graphical edition \end{SDT} and standard scripts see
\ser{femp}. 

An element property is normally defined as a row in the {\sl element property matrix} {\tt il}. Such rows give a declaration of the general form {\tt [ProId Type Prop]} with

\vs\noindent\begin{tabular}{@{}p{.15\textwidth}@{}p{.85\textwidth}@{}}
%
\rz{\tt ProId} & a positive integer identifying a particular element property. \\
\rz{\tt Type}  & a positive real number built using calls of the form \femat{\tt ('p\_beam','SI',1)}, the {\tt subtype} integer is described in the {\tt p\_} functions.\\
\rz{\tt Prop}  & as many properties (real numbers) as needed (see \femat, \psolid\ for details).
%
\end{tabular}

Additional information can be stored as an entry of type {\tt 'pro'} in the model stack which has data stored in a structure with fields
\index{data structure!element property}

\vs\noindent\begin{tabular}{@{}p{.15\textwidth}@{}p{.85\textwidth}@{}}
%
\rz{\tt .name} & description of property. \\
\rz{\tt .il}   & a single value giving the {\tt ProId} of the corresponding row in the {\tt il} matrix or row of values Resolution of the true {\tt .il} value is done by {\tt il=fe\_mat('getil',model)}. \\ 
& When defining {\tt il} in a stack entry {\tt pro.il} field, values may be variable in space or dependent on external constants, the property value in {\tt .il} (any column except {\tt ProId} and {\tt Type}) should then be {\tt -1} for interpolation in {\tt GetIl} using the {\ti pro.field} data, {\tt -2} for interpolation using the table at each integration point, {\tt -3} for direct use of a {\tt FieldAtNode} value as constitutive value (requires {\tt pro.EC.nodeEt} field to be defined). Note that the this cannot be applied to interpolate integration rule selection in volumes. \\
\rz{\tt .unit} & a two character string describing the unit system (see the \ltr{fe\_mat}{Convert} and \ts{Unit} commands)\\
\rz{\tt .type} & the name of the property function handling this particular type of element properties (for example \pbeam)\\
\rz.\htt{NLdata} & used to stored non-linear property information. See \nlspring. \\
\rz{\tt .MAP} & specifications of a field at node, see \ser{VectFromDir}\\
\rz{\tt .gstate} & specifications of a field at integration points, see \ser{VectFromDir}\\
\rz{\ti .field} & can be a structure allowing the interpolation of a value called {\ti field} based on the given table. Thus \par {\tt pro.A=struct('X',[-10;20],'Xlab',\{\{'x'\}\},'Y',[10 20]*1e6)} will interpolate value $A$ based on field {\tt x}. The positions of interpolated variables within the {\tt il} row are given by {\tt list=feval(pro.type, 'propertyunittype cell', subtype)}. 
%
\end{tabular}

The handling of a particular type of constants should be fully contained in the {\tt p\_*} function. The meaning of various constants should be defined in the help and {\sc TeX} documentation. The subtype mechanism can be used to define several behaviors of the same class. The generation of the {\tt integ} and {\tt constit} vectors should be performed through a \ts{BuildConstit} call that is the same for a full family of element shapes. The generation of \hyperlink{EltConst}{\tt EltConst} should similarly be identical for an element family.


%--------------------------------------------------------------------------
\csection{DOF definition vector}{mdof}%
\index{degree of freedom (DOF)!definition vector} 
\index{degree of freedom (DOF)!nodal}\index{mdof}

The meaning of each Degree of Freedom (DOF) is handled through DOF definition vectors typically stored in {\tt .DOF} fields (and columns of {\tt .dof} in test cases where a DOF specifies an input/output location). All informations defined at DOFs (deformations, matrices, ...) should always be stored with the corresponding DOF definition vector. The \fec\ function supports all standard DOF manipulations (extraction, conversion to label, ...)

\lvs {\bf Nodal DOFs} are described as a single number of the form {\tt NodeId.DofId} where {\tt DofId} is an integer between {\tt 01} and {\tt 99}.  For example DOF 1 of node 23 is described by {\tt 23.01}. By convention

\begin{Eitem}
%
\item DOFs {\tt 01} to {\tt 06} are, in the following order $u$, $v$, $w$ (displacements along the global coordinate axes) and $\theta_{u}$, $\theta_{v}$, $\theta_{w}$ (rotations along the same directions)

\item DOFs {\tt 07} to {\tt 12} are, in the following order $-u$, $-v$, $-w$ (displacements along the reversed global coordinate axes) and $-\theta_{u}$, $-\theta_{v}$, $-\theta_{w}$ (rotations along the same directions). This convention is used in test applications where measurements are often made in those directions and not corrected for the sign change. 
It should not be used for finite element related functions which may not all support this convention.

\end{Eitem}

While these are the only mandatory conventions, other typical DOFs are {\tt .19} pressure, {\tt .20} temperature, {\tt .21} voltage, {\tt .22} magnetic field.

In a small shell model, all six DOFs (translations and rotations) of each node would be retained and could be stacked sequentially node by node.  The DOF definition vector {\tt mdof} and corresponding displacement or load vectors would thus take the form

\begin{eqsvg}{f33}
  \texttt{mdof} = \ma{\ba{c} \texttt{1.01} \\ \texttt{1.02} \\ \texttt{1.03} \\ \texttt{1.04} \\ \texttt{1.05} \\ \texttt{1.06} \\ 
  \vdots \ea} \hbox{,\ } \texttt{q} = \ma{\ba{ccc} u_1 & u_2 \\ v_1 & 
  v_2 \\ w_1 & w_2 \\ \theta_{u1} & \theta_{u2} & \ldots \\ \theta_{v1} & 
  \theta_{v2} \\ \theta_{w1} & \theta_{w2} \\ \vdots && \ddots \ea} \hbox{\ 
  and \ } \texttt{F} = \ma{\ba{ccc} F_{u1} & F_{u2} \\ F_{v1} & F_{v2} \\ 
  F_{w1} & F_{w2} \\
  M_{u1} & M_{u2} & \ldots\\ M_{v1} & M_{v2} \\ M_{w1} & M_{w2} \\ \vdots 
  && \ddots \ea}
\end{eqsvg}

Typical vectors and matrices associated to a DOF definition vector are

\begin{Eitem}

\item {\bf modes} resulting from the use of \feeig\ \begin{SDT}or read from FE code results (see \nasread, \ufread)\end{SDT}. 

\item {\bf input and output shape matrices} which describe how forces are applied and sensors are placed (see \fec, \feload
\begin{SDT}, 
\hyperlink{bc}{\tt bc} \forlatex{ page \pageref{s*bc}}
\end{SDT}
).

\item {\bf system matrices} : mass, stiffness, etc.  assembled by \femk.

\item {\bf FRF} test data.  If the position of sensors is known, it can be used to animate experimental deformations 
(see \feplot\
\begin{SDT}
, \xfopt, and \fesens
\end{SDT}
).

\end{Eitem}

Note that, in Matlab version, the functions \feeig\ and \femk, for models with more than 1000 DOFs, renumber DOF internally so that you may not need to optimize DOF numbering yourself. In such cases though, {\tt mdof} will not be ordered sequentially as shown above.


{\bf Element DOFs} are described as a single number of the form {\tt -EltId.DofId} where {\tt DofId} is an integer between {\tt 001} and {\tt 999}.  For example DOF 1 of the element with ID {\tt 23001} is described by {\tt -23001.001}.\index{degree of freedom (DOF)!element}\index{element!EGID}\index{EGID}\index{element!identification number (EltId)}
Element DOFs are typically only used by superelements \begin{SDT}(see \ser{secms})\end{SDT}. Due to the use of integer routines for indexing operations, you cannot define element DOFs for elements with and {\tt EltId} larger than 2 147 484.

%----------------------------------------------------------------------------
\csection{FEM model structure}{model}\index{model}\index{data structure!model}

Finite element simulations are best handled using standard data structures supported by {\sl OpenFEM}. The two main data structures are {\tt model} which contains information needed to specify a FEM problem, and {\tt DEF} which stores a solution. 

Finite element models are described by their topology (\hyperlink{node}{nodes}, \hyperlink{elt}{elements} and possibly coordinate systems), their properties (\hyperlink{pl}{material} and \hyperlink{il}{element}). Computations performed with a model are further characterized by a \ltt{case} as illustrated in \ser{casegui} and detailed in \ser{stackref}.

Data structures describing finite element models have the following standardized fields, where only nodes and elements are always needed.

\lvs\noindent\begin{tabular}{@{}p{.15\textwidth}@{}p{.85\textwidth}@{}}
\rz{\tt .bas}    &  local \hyperlink{basis}{coordinate system} definitions. \\
\rz{\tt .cta}  &  sensor observation matrix. 
\begin{SDT}
Used by \fesens. 
\end{SDT}
\\
\rz{\tt .copt}  &  solver options. 
\begin{SDT}
For use by \upcom. 
\end{SDT}
This field is likely to disappear in favor of defaults in \sdtdef. \\
\rz{\tt .DOF}    &  \rz\dofdef\ for the matrices of the model. Boundary conditions can be imposed using cases. \\
\rz{\tt .Elt}    &  \rz\hyperlink{elt}{elements}. This field is {\bf mandatory}. \\
\rz{\tt .wd}    &  working directory \\
\rz{\tt .file}    &  Storage file name.
\begin{SDT}
 Used by \upcom.
\end{SDT}
\\
\rz{\tt .il}    &  element property description matrix. Can also be stored as {\tt 'pro'} entries in the {\tt Stack}.\\
\rz{\tt .K\{{\ti i}\}}   &  cell array of constant matrices for description of model as a linear combination. Indices {\ti i} match definitions in {\tt .Opt(2,:)} and {\tt .Opt(3,:)}. Should be associated with a {\tt .Klab} field giving a string definition of each matrix.
\begin{SDT}
See details in the \fesuperb\ reference.
\end{SDT}
\\
\rz{\tt .mind}    &  element matrix indices. 
\begin{SDT}
Used by \upcom.
\end{SDT}
\\
\rz{\tt .Node}    &  \rz\hyperlink{node}{nodes}. This field is {\bf mandatory}.   \\
\rz{\tt .Opt}    &  options characterizing models that are to be used as superelements. \\
\rz{\tt .pl}    &  material property description matrix. Can also be stored as {\tt 'mat'} entries in the {\tt Stack}. \\
\rz{\tt .Patch}    &  Patch face matrix. 
\begin{SDT}
See \fesuperb. 
\end{SDT}
\\
\rz\hyperlink{stackref}{\tt .Stack}    &  A cell array containing optional properties further characterizing a finite element model. See \stackget\ for how to handle the stack and the next section for a list of standardized entries. \\
\\
\rz{\tt .TR}  &  projection matrix. 
\begin{SDT}
See \fesuperb. 
\end{SDT}
\\
\rz{\tt .unit}  &  main model unit system (see \ltr{fe\_mat}{Convert} for a list of supported unit systems and the associated two letter codes). Specifying this field let you perform conversion from materials defined in {\tt US} system unit from the GUI.
\\
\rz{\tt .nmap}    &  mapping between ids (NodeId, MatId, ProId, BasId,...) and associated labels. This is managed by \ltr{sdth}{urn.nmap} \\
\end{tabular}

Obsolete fields are {\tt .Ref} Generic coordinate transformation specification, {\tt .tdof} test DOF field (now in \ltt{SensDof} entries). 

%----------------------------------------------------------------------------
\csection{FEM stack and case entries}{stackref}\index{stack}\index{stack entries}

Various information are stored in the {\tt model.Stack} field.
\begin{SDT}
If you use a \sdth\ refering to a \feplot\ figure, modification of the model and case entries is often easier using {\tt cf.Stack} calls (see \feplot).
\end{SDT}

Currently supported entry types in the stack are

\lvs\noindent\begin{tabular}{@{}p{.15\textwidth}@{}p{.85\textwidth}@{}}
%
\rz\ts{case}   &  defines a \ltt{case} : boundary conditions, loading, ...  \\
\rz\ts{curve}  &  curve to be used for simulations (see \fecurve).\\
\rz\ts{info}   &  non standard information used by solvers or meshing procedures (see below).\\
\rz\ts{info,map}    & used to define a normal MAP, see \ltr{feutil}{GetNormal} for format \\
\rz\ts{mat}    &  defines a \hyperlink{pl}{material} entry. \\
\rz\ts{pro}    &  defines an \hyperlink{il}{element property} entry. \\
\rz\ts{SE}     &  defines a \hyperlink{fesuper}{superelement} entry. \\
\rz\ts{sel}    &  defines a \hyperlink{findelt}{element selection}. \\
\rz\ts{seln}   &  defines a \hyperlink{findnode}{node selection}. Typically a structure with fields {\tt .ID} giving the reference number and {\tt .data} giving either node numbers or a node selection command. \\
\rz\httts{set} &  defines a set that is a structure with fields 
\begin{itemize}
\item {\tt .ID} (a reference number of the set), 
\item {\tt .type} nature of the set The following set types are accepted:
 \begin{itemize}\item \ts{NodeId} data is a column of node numbers.
 \item \ts{EltId} data is a column of element numbers.
 \item \httts{FaceId}, \httts{EdgeId} data is two columns giving {\tt EltId} and face/edge number (as detailed in \integrules, or resulting from ({\tt tetra10('faces'), ...}). Face sets are often used to define loaded surfaces.  \httts{FaceId}, \httts{EdgeId} are signed values relative the underlying element orientation. Using negative identifiers, will generate the same face or edge selection but with reversed orientation (outer normals or edge direction).
 \item \httts{DOF} values for DOF sets.
 \end{itemize} 
\item {\tt .data} defines the data as function of type {\tt NodeId, ...}. For {\tt FaceId,EdgeId} 
\begin{itemize}
\item external code imports like used for \femlink\ face identifiers conventions may vary, so that read data may not be in coherence with SDT notations. To alleviate the problem, one can add field {\tt ConvFcn} to provide a conversion function. The conversion function can be called depending on the element type {\tt ElemF} with the syntax
\begin{itemize}
\item {\tt feval(ConvFcn,['conv faceNum.' ElemF]);} that should rethrow a renumbering vector giving in sorted SDT face numbering order the corresponding face index of the external convention.
\item {\tt feval(ConvFcn,['conv face.' ElemF]);} that should rethrow the list of nodes per face (by line) in the original external face convention (but with SDT node numbering convention).
\end{itemize}
\item A third column can be added to specify subgroups within the set and a {\tt .NodeCon} sparse matrix can be used to specify nodes (rows) connected to each subgroup (column). This is to be replaced by \ts{meta-set}.
\end{itemize}
\item {\tt .lab} can be a cell array associating names with each row of {\tt .data}. These can for example be used to identify nodes by a name. 
\end{itemize} \\ % End of main set itemize 
%
\rz\ts{set}&  \httts{meta-set} is the most recent set format. This structure defines a list of sub-sets gathered in a main set. The structure has fields
 \begin{itemize}
 \item {\tt .name} The set name. 
 \item{\tt .type} a cell array of basic set types, either {\tt NodeId}, {\tt EltId}, {\tt FaceId}, {\tt EdgeId}.
 \item {\tt .SetNames} A two column cell array of sub-set names and groups. One can thus define for each set name a specific group to ease up navigation through levelling per group.
 \item {\tt .EltId} A one column vector of {\tt EltId}, usually the complete model element identifiers list.
 \item {\tt .NodeId} A one column vector of {\tt NodeId}, usually the complete model node identifiers.
 \item {\tt .SConn} A sparse logical connectivity matrix of size {\tt length(EltId)} by {\tt size(SetNames,1)} with true values when the {\tt EltId} indexed by the line number of {\tt SConn} belongs to the sub-set indexed by the column number of {\tt .SConn}.
\item {\tt .NConn} A sparse logical connectivity matrix of size {\tt length(NodeId)} by {\tt size(SetNames,1)} with true values when the {\tt NodeId} indexed by the line number of {\tt .NConn} belongs to the sub-set indexed by the column number of {\tt .NConn}.
\item {\tt .NNode} A sparse {\tt NodeId} to node index transformation that has to be coherent with the {\tt .NodeId} field.
 \end{itemize} 
 This structure is the most recent, and will support future integration developments. One is able to call sub-sets in specific \hyperlink{findelt}{\ts{FindEltString}} calls. \\
& The \ltr{feutil}{AddSet} commands let you define a set from a selection. \ts{meta-set} is accessible with the \ts{-Append} command option.\\
%
\end{tabular}

Currently reserved names for \httts{info} entries are 

\begin{tabular}{@{}p{.25\textwidth}@{}p{.75\textwidth}@{}}
\rz\httts{DefaultZeta} &  value to be used as default modal damping ratio (viscous damping). The default loss factor if needed is taken to be twice that value.' Default damping is only used when no other damping information is available. \index{loss factor}\index{damping ratio}\index{eta}\index{zeta}\\
\rz\httts{DefaultEta} & (discontinued) value to be used as default
loss factor should be replaced by \ts{DefaultZeta=eta/2}. \index{loss factor}\index{damping ratio}\\
\rz\ts{EigOpt} & gives real eigenvalue solver options (see \feeig). \\
\rz\ts{FluidEta}     &  Default loss factor for use in vibroacoustic fluid computations\index{loss factor}. \\
\rz\httts{Freq} & Frequencies given as a structure with field {\tt .data} with frequency values and {\tt .ID} a integer identifier. A {\tt .unit} field can specify \ts{rad/s},\ts{Hz},\ts{rev/mn},\ts{RPM}.  \begin{SDT}{\tt f=fe\_def('DefFreq',model)} is used to obtain the frequency vector in Hz.\end{SDT}\\
\rz\ts{NewNodeFrom} & integer giving the next {\tt NodeId} to be used when adding nodes to the model (used by some commands of \feutil).\\
\rz\httts{Omega} & rotation vector used for rotating machinery computations (see {\tt fe\_cyclic}) can be specified as a structure for unit selection. For example  {\tt r1=struct('data',250,'unit','RPM');f\_hz=fe\_def('deffreq',r1)}\\
\rz\ts{OrigNumbering} & original node numbering (associated with \ltr{feutil}{Renumber} command). Two {\tt int32} columns giving original and new node numbers.\\
\rz\httts{StressCritFcn} & string to be evaluated for a specific stress criterion, see \festress. \\
\end{tabular}

\begin{SDT}
\begin{tabular}{@{}p{.25\textwidth}@{}p{.75\textwidth}@{}}
\rz\ts{Rayleigh}  &  defines a \hyperlink{damp}{Rayleigh} damping entry.\\
\rz\ts{MifDes}    &  defines the list of desired response output (see {\tt fe2xf}).\\
\rz\ts{NasJobOpt} &  structure with options to be used for automated job runs by the  \hyperlink{naswrite}{NASTRAN job handler}.\\
\rz\ts{NastranJobEdit}  &  cell array giving a list of job editing commands to be used through a \ltr{naswrite}{EditBulk} call. \\
\end{tabular}
\end{SDT}

\begin{tabular}{@{}p{.25\textwidth}@{}p{.75\textwidth}@{}}
\rz\ts{TimeOpt}    &  gives time solver options (see \fetime).\\
\rz\ts{TimeOptStat} &  gives non-linear static solver options (see \fetime).\\
\end{tabular}

Currently reserved names for {\tt curve} entries are
\begin{itemize}
\item \ts{StaticState}  used to assemble prestressed matrices (type 5). 
\item \ts{q0}  used to initialize time simulations and for non-linear analyses
\end{itemize}


\index{cases}\index{data structure!case}

A \htt{case} type defines finite element boundary conditions, applied loads, physical parameters, ... The associated information is stored in a {\tt case} data structure with fields

\lvs\noindent\begin{tabular}{@{}p{.2\textwidth}@{}p{.8\textwidth}@{}}
%
\rz{\tt Case.Stack}    &  list of boundary conditions, constraints, parametric design point, and loading cases that need to be considered. A table of accepted entries is given under \fecase. Each row gives {\tt \{Type,Name,data\}}. \\
\rz{\tt Case.T}        & basis of subspace verifying fixed boundary conditions and constraints. \\
\rz{\tt Case.DOF}      &  \rz\dofdef\ describing the columns of {\tt T}, the rows of {\tt T} are described by the {\tt .DOF} field of the model. \\
%
\end{tabular}

The various cases are then stored in the {\tt .Stack} field of the model data structure (this is done by a call to \fecase).\begin{SDT} If you use a \sdth\ referring to a \feplot\ figure, modification of the case entries is often easier using {\tt cf.CStack} calls (see \feplot). \end{SDT} 

%----------------------------------------------------------------------------
\csection{FEM result data structure}{def}\index{def}\index{data structure!deformation}


Deformations resulting from finite element computations (\feeig, \feload, \ldots) are described by {\tt def} structures with fields

\lvs\noindent\begin{tabular}{@{}p{.15\textwidth}@{}p{.85\textwidth}@{}}
%
\rz{\tt .def}    &  deformations ($NDOF$ by $NDef$ matrix)  \\
\rz{\tt .DOF}    &  \rz\dofdef, note that the \ltt{.tdof} field is used for responses at sensors and the \ltt{.dof} field for input/output pairs \\
\rz{\tt .data}   &  (optional)  ($N_{Def}$ by $N_{info}$ vector or matrix) characterizing the content of each deformation (frequency, time step, ...)  \\

&\\
\rz{\tt .Xlab}   &  (optional)  {\tt \{'DOF',\{'Freq';'Index'\}}\} cell array describing the columns of data.   \\
\rz{\tt .defL}  &  (optional) displacement field corresponding to the left eigenvectors obtained from \feceig.\\
\rz\ltt{.fun}   &  (optional) function description {\tt [Model Analysis Field FieldType Format NDV]}. This is based on the UNV 55 format detailed below. Typically field with {\tt [0 fe\_curve('TypeAnalysis')]}. This field is needed for proper automated display setup. \\
\rz{\tt .lab}   &  (optional) cell array of strings characterizing the content of each deformation (columns of {\tt .def}). For large arrays, the use of a {\tt .LabFcn} is preferable. \\
\ts{.ImWrite} & (optional)  can be used to control automated multiple figure generation, see \ltr{iicom}{ImWrite}.\\
\rz{\tt .LabFcn} & callback for label generation see \ltr{fecom}{LabFcn}\\
\rz{\tt .Legend} & data for legend generation, see \ltr{fecom}{Legend}\\
\rz{\tt .label}   &  (optional) string describing the content \\
\rz{\tt .DofLab}    & optional cell array of strings specifying a label for each DOF. This is used for display in \iiplot. \\
&\\

\rz{\tt .scale}   &  field used by \feplot\ to store scaling information. \\
%
\end{tabular}


The \htt{.fun} field is a numeric row with values (a typical value for static responses is {\tt def.fun=[0 1 0]})

\begin{itemize}
\item {\tt Model} (0 Unknown, 1 Structural, 2 Heat Transfer, 3 Fluid Flow)
\item {\tt Analysis} see list with {\tt fe\_curve('TypeAnalysis')}
\item {\tt Field} see list with 0: Unknown (or general SDT), 1: Scalar, 2: Tx Ty Tz, 3: Tx Ty Tz Rx Ry Rz, 4: Sxx Sxy Syy Sxz Syz Szz, 5: Sxx Syx Szx Sxy Syy
Szy Sxz Syz Szz
\item {\tt FieldType} see list with {\tt fe\_curve('typefield')}\\
\item {\tt Format} 0 default, 2 Real, 5 Complex\\
\item {\tt NDV} Number Of Data Values Per Node (0 for variable number)\\
\end{itemize}

\begin{SDT}
SDT provides a number of utilities to manipulate deformation structures. In particular you should use
\begin{itemize}
\item  {\tt def=fe\_def('subdef',def,ind)} extracts some deformations (columns of {\tt def.def}). You can select based on the data field, for example with {\tt ind=def.data(:,1)>100}.
\item   {\tt def=fe\_def('AppendDef',def,def1)} combines two sets of deformations
\item  {\tt def=fe\_def('SubDof',def,DOF)} extracts some DOF (rows of {\tt def.def}). To select based on DOF indices, use  {\tt def=fe\_def('SubDofInd',def,ind)}.
\item {\tt def=feutilb('placeindof',DOF,def)} is similar but {\tt DOF} may be larger than {\tt def.DOF}.

\item {\tt fe\_def('SubDofInd-Cell',def,ind\_dof,ind\_def) } return clean display of deformation as a cell array.
\end{itemize}
\end{SDT}
%----------------------------------------------------------------------------
\csection{Curves and data sets}{curve}\index{curve}\index{data structure!curve}

Curves are used to specify \lts{curve}{Inputs} (for time or frequency domain simulation) and store results from simulations. The basic formats are the \lts{curve}{Multi-dim curve} and FEM result \ltt{def}. For experimental modal analysis, \lts{curve}{Response data} and \lts{curve}{Shapes at DOFs} are also used. 

\begin{SDT} All these formats can be displayed using the \iiplot\ interface. For extraction see \ltr{fe\_def}{SubCh}.\end{SDT}

% -------------------------------------------------------------------------
\ruic{curve}{Multi-dim curve}{}

A curve is a {\tt data} structure with fields

\lvs\noindent\begin{tabular}{@{}p{.2\textwidth}@{}p{.8\textwidth}@{}}
 
\rz{\tt .X}             &  axis data. A cell array with as many entries as dimensions of {\tt .Y}. Contents of each cell can be
\begin{itemize}
\item a vector (for example vector of frequencies or time steps), 
\item a matrix with as many rows a steps in {\tt curve.Y}. Each column then corresponds to a different definition of the same data (time and position for example) and you can have as many rows in {\tt curve.Xlab\{i\}} as colums.
\item a cell array describing data vectors in {\tt .Y} (for example response labels) with as many rows as elements in corresponding dimension of {\tt .Y}. In such a cell array, column 2 is for units and 3 for unit type (see \ltr{fe\_curve}{datatype}). To use a specific {\tt curve.X\{i\}} to generate labels for the data, specify the index of the associated dimension in {\tt curve.Ylab}.  
\end{itemize}
\\
 & .X giving x-axis data as a vector is obsolete and should be avoided. \\
\rz\htt{.Xlab}          &  a cell array giving the meaning of each entry in {\tt .X}. Each cell can be a string (giving the dimension name) or itself a cell array with columns giving {\tt \{'name','UnitString',unitcode,'fmt'\}}.  Typical entries are obtained using the \ltr{fe\_curve}{datatype}\ts{cell} command. Multiple rows can be used to describe multiple columns in the {\tt .X} entry (matrix input for {\tt curve.X\{i\}}). \\
& \ts{fmt}, if provided, gives a formatting instruction for
example \ts{'length=\%i m'}. If more intricate formatting is needed a callback can be obtained with {\tt \verb+'#st3{j2}=sprintf(''PK=%.2fkm'',r2(j2)*1e-3);'+}.\\
& \ts{unitcode=struct('coef',1,'DispUnit','val')} can be used to distinguish the unit for curve display without modifying the underlying data. \\

\rz{\tt .Y}             &  response data with as many dimensions as the length of {\tt curve.X} and {\tt curve.Xlab}. If a 2D matrix rows correspond to {\tt .X\{1\}} values and columns are called {\sl channels} described by  {\tt .X\{2\}}\index{channel}. \\
\rz{\tt .Ylab}          &  describes content of {\tt .Y} data. It can be a string, a 1x3 unit type cell array (see the {\tt .Xlab} format), or a number that indicates which dimension (index in {\tt .X\{i\}} field cell array) describes the {\tt .Y} unit. \\

\rz{\tt .ID}            &  Optional. It can be used to generate automatically vertical lines in iiplot. See \ltr{ii\_plp}{Call from iiplot} for more details.\\\rz{\tt .name}          &  name of the curve used for legend generation.\\
\rz{\tt .dof}          &   Optional description of input/output pairs, see \ltt{.dof}. \\
\end{tabular}

\noindent\begin{tabular}{@{}p{.2\textwidth}@{}p{.8\textwidth}@{}}
 \rz{\tt .type}          &   Optional. \rz{\tt 'fe\_curve'}.\\
%\rz{\tt .unit}          &  unit system of the curve (see \ltr{fe\_mat}{Convert}).\\
\rz{\tt .Interp}        &  optional interpolation method. Available interpolations are \ts{linear}, \ts{log}, \ts{stair}, \ts{periodic}.\\
\rz{\tt .Extrap}        &  optional extrapolation method. Available extrapolations are \ts{flat}, \ts{zero} (default for \feload) and \ts{exp}.\\
\rz{\tt .PlotInfo}      &  indications for automated plotting, see \ltr{iiplot}{PlotInfo} \\
\rz{\tt .DimPos}        &  order of dimensions to be shown by \iiplot. 
%\rz{\tt .Z}             &  (obsolete) should be stored as a third dimension in {\tt .Y} and filling of {\tt .X\{3\}}. \\
%\rz{\tt .data}          &  (obsolete) a matrix with one row per channel (column of {\tt .Y}). This is used to store DOF information for responses, pole information for modes, ... \\
%\rz{\tt .*unit}         &  (obsolete) a cell array with three columns giving {\tt label} the meaning of the $x$ axis, {\tt ulabel} the unit label for the $x$ axis, and {\tt typ} four values giving the type number, followed by length, force, temperature and time unit exponents (these are used for automated unit system conversion). Typical fields can be generated with \fecurve{\tt ('DatatypeCell','Time')}. This information should now be stored as entries in {\tt .X\{3\}} \\
%
\end{tabular}

The following gives a basis generation example. 

%begindoc
\begin{verbatim}
 t=linspace(0,10,100)';lab={'ux';'uy'};
 C1=struct('X',{{t,lab}},'Xlab',{{'Time','DOF'}}, ...
  'Y',[sin(t) cos(t)],'name','Test');
 iicom('curveinit',C1.name,C1);iicom('ch1:2');
\end{verbatim}%enddoc

% -------------------------------------------------------------------------
\ruic{tdof}{DOF, tdof (outputs), dof (input/output pair)}{}


SDT identifies quantities involved in FEM and test. Different fields are used for different context. 
\begin{itemize}
 \item {\tt .DOF} is used to identify fields at nodes. This is the standard {\sl DOF definition} of the form {\tt NodeID.DOFID} introduced in \ser{mdof}. 
 \item \htt{.dof} is a matrix used to identify input/output pairs. The columns are
 %
 \begin{enumerate}
  \item {\tt RespNodeID.RespDOFID} identifier of the output / sensor. This is typically called {\tt SensId}
  \item {\tt ExciNodeID.ExciDOFID } identifier of the input / actuator
  \item {\tt address } are optional integer numbers used to identify columns of {\tt xf} matrices. They typically correspond to a measurement channel number.
  \item {\tt RespGroupID} optional identifiers of group names given in the {\tt nmap('Map:Group')} entry. 
  \item {\tt ExciGroupID} optional identifiers of group names given in the {\tt nmap('Map:Group')} entry. (this is really only supported by \ufread). 

  \item {\tt FunID} correspond to universal file format specification but unused. 
  \item {\tt LoadCase} identifier of experiment.
  \item {\tt ZaxisValue} for experiments that depend on another parameter (rotation speed, ...)
 \end{enumerate} 
this field corresponds to data in line 6 of \ltr{ufread}{58} except for address, stored in the measurement label in Test-Lab for example. 

\item {\tt .tdof} is a column vector of {\tt SensId} typically with the form {\tt RespNodeID.RespDOFID}) used for response at sensors. It does not allow repetitions found in the {\tt .dof} field where the same sensor can be used for multiple inputs.  

For test/analysis correlation, it is associated with the sensor topology definition described in~\ser{sensor} where additional columns are added to the {\tt .tdof} field to describe the supporting node and a general measurement direction. 
 
\end{itemize}




% -------------------------------------------------------------------------
\ruic{curve}{FEM Result}{}

See \ser{def} or {\tt sdtweb('def')}, uses the {\tt .def, .DOF, .data} fields. 

% -------------------------------------------------------------------------
\ruic{curve}{Inputs}{}

Inputs for time or frequency simulations are stored as entries {\tt \{'curve', Name, data\}} in the model stack or in the case of inputs in the {\tt load.curve} cell array. 

A curve can be used to define a time (or frequency) dependent load $\ve{F}=\ma{B}\ve{u}$. $\ma{B}$ defines the spatial distribution of the load on DOFs and its unit is the same as $F$. $\ma{B}$ is defined by a {\tt DOFLoad} entry in the Case. $\ve{u}$ defines the time (or frequency) dependency as a unitless curve. There should be as many curves as columns in the matrix of a given load {\tt def}. If a single curve is defined for a multi-load entry, it will affect all the loads of this entry.

As an illustration, let us consider ways to define a time dependent load by defining a {\tt .curve} field in the load data structure. This field may contain a string referring to an existing curve (name is {\tt 'input'} here)

%begindoc
\begin{verbatim}
 model=fe_time('demo bar');fe_case(model,'info')

 % Define input curve structure (single input step) 
 % For examples see: sdtweb fe_curve#Test 
 model=fe_curve(model,'set','input','TestStep t1=1e-3');

 % define load.curve{1} to use that input
 model=fe_case(model,'setcurve','Point load 1','input');

 % Run a simulation
 TimeOpt=fe_time('timeopt newmark .25 .5 0 1e-4 100');
 model=stack_set(model,'info','TimeOpt',TimeOpt);
 def=fe_time(model); feplot(model,def); fecom ColorDataAll
\end{verbatim}%continuedoc

\begin{SDTDEV}
%continuedoc
\begin{verbatim}
disp('REGRESSION TEST:')
if size(def.def,1)~=500 || size(def.def,2)~=101 || abs(norm(def.def)-1.5543e-002)>1e-5
 error('Something has changed')
else disp('OK!')
end
\end{verbatim}%enddoc
\end{SDTDEV}

It is also possible to directly define the {\tt .curve} field associated with a load

%begindoc
\begin{verbatim}
 model=fe_time('demo bar');fe_case(model,'info')
 model=fe_case(model,'remove','fd'); % loads at both ends
 data=struct('DOF',[1.01;2.01],'def',1e6*eye(2),...
             'curve',{{'test ricker dt=1e-3 A=1',...
                       'test ricker dt=2e-3 A=1'}});
 model = fe_case(model,'DOFLoad','Point load 1',data);

 TimeOpt=fe_time('timeopt newmark .25 .5 0 1e-4 100');
 model=stack_set(model,'info','TimeOpt',TimeOpt);
 def=fe_time(model); feplot(model,def); fecom ColorDataAll
\end{verbatim}%continuedoc

\begin{SDTDEV}
%continuedoc
\begin{verbatim}
disp('REGRESSION TEST:')
if size(def.def,1)~=500 || size(def.def,2)~=101 || abs(norm(def.def)-1.297379279e-2)>1e-5
 error('Something has changed')
else disp('OK!')
end
\end{verbatim}%enddoc
\end{SDTDEV}

% -------------------------------------------------------------------------
\ruic{curve}{Response data associated with inputs and outputs}{}

Response data sets \htt{xfstruct} correspond to groups of universal files of type \ltt{UFF58} that have the same properties (type of measurement, abscissa, units, ...). They are used for identification with \idcom\ while the newer \hyperlink{curve}{curve} format is used for simulation results. They are characterized by the following fields

\vs\begin{tabular}{@{}p{.15\textwidth}@{}p{.85\textwidth}@{}}
%
\rz{\tt .w}     & abscissa values \\
\rz{\tt .xf}    & response data, one column per response, see \ser{xf}\\
\rz\ltt{.dof}   & IO characteristics of individual responses (one row per column in the
        response data as detailed in \ltt{.dof}). To extract response at sensors, \ltt{.tdof} field, use \idrm. \\
\rz{\tt .fun}   & general data set options, contain {\tt [FunType DFormat NPoints XSpacing Xmin XStep ZValue]} as detailed in \ltr{ufread}{58}. \\
\rz{\tt .idopt} & options used for identification related routines
        (see \idopt)\\
\rz{\tt .header} &  header (5 text lines with a maximum of 72 characters) \\
\rz{\tt .x}     &  abscissa description (see {\tt xfopt('\_datatype')})\\
\rz{\tt .yn}    &  numerator description (see {\tt xfopt('\_datatype')})\\
\rz{\tt .yd}    &  denominator description (see {\tt xfopt('\_datatype')}) \\
\rz{\tt .z}     &  third axis description (see {\tt xfopt('\_datatype')}) \\
\rz{\tt .group} & (optional) cell array containing DOF group names. Get label with {\tt c.group(c.dof(:,4))} for response and {\tt c.group(c.dof(:,5))} for excitation. \\
\rz{\tt .load}  & (optional) loading patterns used in the data set \\
\end{tabular}  

The {\tt .w} and {\tt .xf} fields contain the real data while other fields give more precisions on its nature. 


The {\tt idopt} field is used to point to identification options used on the data set. These should point to the figure options {\tt ci.IDopt}.\index{IDopt}

The {\tt .group} field is used to associate a name to the group identification numbers {\tt RespGroupID} {\tt ExciGroupID} defined in the {\tt .dof} columns 4 and 5. These names are saved by \ufwrite\ and used for geometry identification.

The {\tt load} field describes {\sl loading cases} by giving addresses of applied loads in odd columns and the corresponding coefficients in even columns. This field is used in test cases with multiple correlated inputs.

% -------------------------------------------------------------------------
\ruic{curve}{Shapes at IO pairs}{}

Shapes at DOFs is used to store modeshapes, time responses defined at all nodes, ... and are written to universal file format 55 (response at nodes) by \ufwrite. The fields used for such datasets are

\begin{tabular}{@{}p{.15\textwidth}@{}p{.85\textwidth}@{}}
%
\rz{\tt .po} & pole values, time steps, frequency values ... 

 For poles, see \iipof\ which allows conversions between the different pole formats. \\
\rz{\tt .res} & residues / shapes (one row per shape). Residue format is detailed in~\ser{res}. \\
\rz\ltt{.dof} & IO description, see \ltt{.dof}. To extract response at sensors, \ltt{.tdof} field, use \idrm.  \\
\rz{\tt .fun} & function characteristics (see \ltt{UFF58}) \\
\rz{\tt .header} &  header (5 text lines with a maximum of 72 characters) \\
\rz{\tt .idopt}   &  identification options. This is filled when the data structure is obtained as the result of an \idcom\ call. \\
\rz{\tt .label}   &  string describing the content \\
\rz{\tt .lab\_in}   &  optional cell array of names for the inputs \\
\rz{\tt .lab\_out}   &  optional cell array of names for the outputs \\
\rz{\tt .group}   & optional cell group names\\
\end{tabular}  


%------------------------------------------------------------------------------
\csection{DOF selection}{adof}\index{adof}\index{degree of freedom (DOF)!selection}\index{degree of freedom (DOF)!definition vector}%\index{selection!DOF}

\fec\ is the general purpose function for manipulating DOF definition vectors. It is called by many other functions to select subsets of DOFs in large DOF definition vectors. DOF selection is very much related to building an observation matrix {\tt c}, hence the name \fec.

For DOF selection, \fec\ arguments are the reference DOF vector {\tt mdof} and the DOF selection vector {\tt adof}. {\tt adof} can be a standard DOF definition vector but can also contain wild cards as follows 

\lvs\noindent
{\tt \verb| NodeId.0    |}  means all the DOFs associated to node {\tt NodeId} \\
{\tt \verb|      0.DofId|} means {\tt DofId} for all nodes having such a DOF\\
{\tt \verb| -EltN.0    |} means all the DOFs associated to element {\tt  EltId}

\lvs Typical examples of DOF selection are 

\lvs {\tt ind = fe\_c(mdof,111.01,'ind');} returns the position in {\tt mdof} of the $x$ translation at node 111. You can thus extract the motion of this DOF from a vector using {\tt mode(ind,:)}. Note that the same result would be obtained using an output shape matrix in the command {\tt fe\_c(mdof,111.01)*mode}.

% \lvs {\tt [m,k,mdof] = fe\_mk(node,elt,pl,il,[],[.01 .02 .06]',0)} 
\lvs {\tt model = fe\_mk(model,'FixDOF','2-D motion',[.03 .04 .05])} 

assembles the model but only keeps translations in the $xy$ plane and rotations around the $z$ axis (DOFs {\tt [.01 .02 .06]'}). This is used to build a 2-D model starting from 3-D elements.

\lvs The \ltr{feutil}{FindNode} commands provides elaborate node selection tools. Thus {\tt femesh('findnode x>0')} returns a vector with the node numbers of all nodes in the standard global variable {\tt FEnode} that are such that their $x$ coordinate is positive. These can then be used to select DOFs, as shown in the section on boundary conditions \ser{mpc}. Node selection tools are described in the next section.

\newpage
%----------------------------------------------------------------------------
\csection{Node selection}{findnode}\index{node!selection}\index{selection!node}


\feutil\ \httts{FindNode} supports a number of node selection criteria that are used by many functions. A node selection command is specified by giving a string command (for example {\tt 'GroupAll'}, or the equivalent cell array representation described at the end of this section) to be applied on a model (nodes, elements, possibly alternate element set).

Output arguments are the numbers {\tt NodeId} of the selected nodes and the selected nodes {\tt node} as a second optional output argument. The basic commands are  
\begin{itemize}
\item {\tt [NodeId,node]=feutil(['findnode ...'],model)} or {\tt node=feutil(['getnode ...'],model)}\\
this command applies the specified node selection command to a {\tt model} structure. For example,
{\tt [NodeId,node] = feutil('findnode x==0',model);} \\selects the nodes in {\tt model.Node} which first coordinate is null.

\item {\tt [NodeId,node]=femesh(['findnode ...'])}\\
this command applies the specified node selection command to the standard global matrices {\tt FEnode}, {\tt FEelt}, {\tt FEel0}, \ldots For example,\\
{\tt [NodeId,node] = femesh('findnode x==0');}
selects the node in {\tt FEnode} which first coordinate is null.
\end{itemize}

Accepted selectors are

\begin{tabular}{@{}p{.25\textwidth}@{}p{.75\textwidth}@{}} \\
%
\rz\ts{GID }\tsi{i} & selects the nodes in the node group \tsi{i} (specified in column 4 of the node matrix). Logical operators are accepted.  \\
\rz\ts{Group }\tsi{i} & selects the nodes linked to elements of group(s) \tsi{i} in the main model. Same as \ts{InElt\{Group }\tsi{i}\ts{\}} \\
\rz\ts{Groupa }\tsi{i} & selects nodes linked to elements of group(s) \tsi{i} of the alternate model \\
\rz\ts{InElt\{}\tsi{sel}\ts{\}} & selects nodes linked to elements of the main model that are selected by the \hyperlink{findelt}{element selection} command \tsi{sel}.\\
\rz\ts{NodeId >}\tsi{i} & selects nodes selects nodes based relation of {\tt NodeId} to integer \tsi{i}. The logical operator \ts{>}, \ts{<}, \ts{>=}, \ts{<=},  \ts{\symbol{126}=}, or \ts{==} can be omitted (the default is then \ts{==}). \\
& {\tt feutil('findnode 1 2',model)} interprets the values as {\tt NodeId} unless three values are given (then interpreted as {\tt x y z}). {\tt feutil('findnode',model,IdList)} should then be used.\\
\rz\ts{NotIn\{}\tsi{sel}\ts{\}} & selects nodes not linked to elements of the main model that are selected by the \hyperlink{findelt}{element selection} command \tsi{sel}.\\

\rz\ts{Plane }\tsi{== i nx ny nz} & selects nodes on the plane containing the node number \tsi{i} and orthogonal to the vector {\tt [}\tsi{nx ny nz}{\tt ]}. Logical operators apply to the oriented half plane. \tsi{i} can be replaced by string \tsi{o xo yo zo} specifying the origin.\\

\end{tabular}

\begin{tabular}{@{}p{.25\textwidth}@{}p{.75\textwidth}@{}}
\rz\ts{rad <=}\tsi{r x y z} & selects nodes based on position relative to the sphere specified by radius \tsi{r} and position \tsi{x y z} node or number \tsi{x} (if \tsi{y} and \tsi{z} are not given). The logical operator \ts{>}, \ts{<}, \ts{>=}, \ts{<=} or \ts{==} can be omitted (the default is then \ts{<=}).\\

\rz\ts{cyl <=}\tsi{r i nx ny nz z1 z2}  & selects nodes based on position relative to the cylinder specified by radius \tsi{r} and axis of direction \tsi{nx ny nz} and origin the node \tsi{i} (NodeId \tsi{i} can be replaced by string \tsi{o xo yo zo}). Optional arguments \tsi{z1} and \tsi{z2} define bottom and top boundaries from origin along cylinder axis.\\

\rz\ts{between}\tsi{n1 n2} & selects nodes located between the two planes of normal directed by \tsi{n1}-\tsi{n2} and respectively passing through \tsi{n1} and \tsi{n2}. \\

\rz\ts{Setname }\tsi{name} & finds nodes based on a set defined in the model stack. Note that the name must not contain blanks or be given between double quotes {\tt \verb+"name"+}. Set can be a {\tt NodeId} or even an {\tt EltId} or {\tt FaceId}, {\tt EdgeId} \ltt{set}. {\tt \verb+"name:con IdList"+} can be used to select a subset connected to nodes in the \ts{IdList}.\\

\rz\ts{x>}\tsi{a} & selects nodes such that their {\sl x} coordinate is larger than \tsi{a}. {\tt x y z r} (where the radius {\tt r} is taken in the $xy$ plane) and the logical operators \ts{>}, \ts{<}, \ts{>=}, \ts{<=}, \ts{==} can be used. \\
& Expressions involving other dimensions can be used for the right hand side. For example \ts{r>.01*z+10}. \\

\rz\tsi{x y z} & selects nodes with the given position. If a component is set to \ts{NaN} it is ignored. Thus {\tt [0 NaN NaN]} is the same as \ts{x==0}. \\
%
\end{tabular}

Element selectors \ts{EGID}, \ts{EltId}, \ts{EltName}, \ts{MatId} and \ts{ProId} are interpreted as \ts{InElt} selections. 

Command option \ts{epsl} \tsi{value} can be used to give an evaluation tolerance for equality logical operators.

Different selectors can be chained using the following logical operations
\begin{itemize}
\item \ts{\&}, finds nodes that verify both conditions.
\item \ts{|}, finds nodes that verify one or both conditions.
\item \ts{\&\~\ } finds nodes that verify the left condition and not the right condition (exclusion from current selection state)
\end{itemize}
Condition combinations are always evaluated from left to right (parentheses are not accepted).

While the string format is typically more convenient for the user, the reference format for a node selection is really a 4 column cell array :

\begin{tabular}{@{}p{.1\textwidth}@{}p{.2\textwidth}@{}p{.2\textwidth}@{}p{.5\textwidth}@{}}
    \{ & Selector & Operator & Data \\
Logical & Selector & Operator & Data \\
\} & &  &  \\
\end{tabular}

The first column gives the chaining between different rows, with {\tt Logical} being either {\tt \&}, {\tt |}, {\tt \&\~\ }, or a bracket {\tt (} and {\tt )}. The {\tt Selector} is one of the accepted commands for node selection (or element selection if within a bracket). The {\tt operator} is a logical operator {\tt >}, {\tt <}, {\tt >=}, {\tt <=},  {\tt \verb+~+=}, or {\tt ==}. The {\tt data} contains numerical or string values that are used to evaluate the operator. Note that the meaning of {\tt \verb+~+=} and {\tt ==} operators is slightly different from base \matlab\ operators as they are meant to operate on sets. 


The \ltr{feutil}{FindNode}\ts{Stack} command returns the associated cell array rather than the resulting selection.


\newpage
%----------------------------------------------------------------------------
\csection{Element selection}{findelt}\index{element!selection}\index{selection!element}

\feutil\ \httts{FindElt} supports a number of element selection criteria that are used by many functions. An element selection command is specified by giving a string command (for example {\tt 'GroupAll'}) to be applied on a model (nodes, elements, possibly alternate element set).

Basic commands are : 
\begin{itemize}
\item {\tt [eltind,elt] = feutil('findelt selector',model);} \\or {\tt elt = feutil('selelt selector',model);} this command applies the specified element selection command to a {\tt model} structure. For example, \\
{\tt [eltind,selelt] = feutil('findelt eltname bar1',model)} selects the elements in \texline {\tt model.Elt} which type is {\tt bar1}.
\item {\tt [eltind,elt] = femesh('findelt selector');}\\
this command applies the specified element selection command to the standard global matrices {\tt FEnode}, {\tt FEelt}, {\tt FEel0}, \ldots For example, {\tt [eltind,selelt] = femesh('findelt eltname bar1')} selects the elements in {\tt FEelt} which type is {\tt bar1}.
\end{itemize}

Output arguments are {\tt eltind} the selected elements indices in the element description matrix and {\tt selelt} the selected elements.

Accepted selectors are

\lvs \begin{tabular}{@{}p{.2\textwidth}@{}p{.8\textwidth}@{}}
%
\rz\ts{ConnectedTo }\tsi{i} & finds elements in a group that contains the nodes \tsi{i}. This calls \ltr{feutil}{DivideInGroups} and thus only operates on groups of elements of a single type.\\
\rz\ts{EGID }\tsi{i}\index{EGID} & finds elements with element group identifier \tsi{i}. Operators accepted.\\
\rz\ts{EltId }\tsi{i} & finds elements with identifiers \tsi{i} in {\tt FEelt}. Operators accepted. \\
\rz\ts{EltInd }\tsi{i} & finds elements with indices \tsi{i} in {\tt FEelt}. Operators accepted. \\
\rz\ts{EltName }\tsi{s} & finds elements with element name \tsi{s}. \ts{EltName flui} will select all elements with name starting with \ts{flui}. \ts{EltName \~\ = flui} will select all elements with name not starting with \ts{flui}. One can select superelements from their name using \ts{EltName SE:}\tsi{SEName}. Selection of all elements but a single SE from its name is obtained using \ts{EltName \~\ = SE:}\tsi{SEName}. Regular expressions on superelement names are accepted, one then replaces token \tsi{SEName} by the prefix {\tt \#} followed by the desired expression, {\it e.g.} \ts{EltName SE:}\tsi{\#tgm*} to select all superlement whose name starts with \ts{tgm}.\\

\rz\ts{Facing > }\tsi{cos x y z} & finds topologically 2-D elements whose normal projected on the direction from the element CG to \tsi{x y z} has a value superior to \tsi{cos}. Inequality operations are accepted.\\

\rz\ts{Group }\tsi{i} & finds elements in group(s) \tsi{i}. Operators accepted.\\
\rz\ts{InNode }\tsi{i} & finds elements with all nodes in the set \tsi{i}. Nodes numbers in \tsi{i} can be replaced by a string between braces defining a \hyperlink{findnode}{node selection command}. For example  {\tt feutil('FindElt withnode \{y>-230 \& NodeId>1000\}',model)}.\\
\rz\ts{MatId }\tsi{i} & finds elements with {\tt MatId} equal to \tsi{i}. Relational operators are also accepted ({\tt MatId~=1:3}, ...).\index{MatId} \\
\rz\ts{ProId }\tsi{i} & finds elements with {\tt ProId} equal to {\ti i}. Operators accepted.\index{ProId} \\

\rz\ts{WithNode }\tsi{i} & finds elements with at least one node in the set \tsi{i}. \tsi{i} can be a list of node numbers.  Replacements for \tsi{i} are accepted as above.  \\
\rz\ts{Set }\tsi{i} & finds elements in element set(s) based on the {\tt .ID} field (see \ltt{set} stack entries). Elements belonging to any set of {\tt ID} of value \tsi{i} will be selected. \\
%
\end{tabular}

\lvs \begin{tabular}{@{}p{.2\textwidth}@{}p{.8\textwidth}@{}}
%
\rz\ts{SetName }\tsi{s} & finds elements in element set named \tsi{s} (see \ltt{set} stack entries).
\begin{itemize}
\item By default an error is thrown if the set name does not exist in stack. Use command {\tt SafeSetName} to get empty results instead.
\item By default no spaces in set names are allowed. For more complicated setnames, place the name into double quotes: {\tt SetName "my set name with spaces"}.
\item Selection by exclusion is possible with token {\tt :exclude}. {\it E.g.} {\tt SetName unused:exclude} will return all elements excluding the elements present in the set named {\tt unused}.
\item Alternative calls to more advanced sets based on connectivity are possible,
 \begin{itemize}
 \item {\tt SetName "name:con IdList"} can be used to select a subset connected to nodes in the \ts{IdList} (assuming the {\tt .NodeCon} field is defined). 
\item {\tt SetName "name:subname"} can be used to select a subset in the set by connectivity format (see \ltt{set}).
 \end{itemize}
 \end{itemize} \\
\rz\ts{WithoutNode }\tsi{i} & finds elements without any of the nodes in the set \tsi{i}. \tsi{i} can be a list of node numbers. Replacements for \tsi{i} are accepted as above.\\
\rz\ts{SelEdge }\tsi{type} & selects the external edges (lines) of the currently selected elements (any element selected before the \ts{SelEdge} selector), any further selector is applied on the model resulting from the \ts{SelEdge} command rather than on the original model. The \ts{-All} option skips the internal edge elimination step. It can be combined with option {\tt -noUni} to keep edge duplicates between elements. \\
 & Type \ts{g} retains inter-group edges. \ts{m} retains inter-material edges. Type \ts{p} retains inter-property edges. \ts{all} retains all edges. The {\tt MatId} for the resulting model identifies the original properties of each side of the edge. The edge number is stored in the column after {\tt EltId}.\\
%
\rz\ts{SelFace }\tsi{type} & selects the external faces (surfaces) of the currently selected elements. The face number is stored in the column after {\tt EltId} to allow set generation. See more details under \ts{SelEdge}. The \ts{-All} option skips the internal face elimination step.  {\bf Warning:} the face number stored in the column after the {\tt EltId} column interferes with the {\tt Theta} property for shell elements (see \quada,\triaa). If the selection output will be used as elements in a model, ensure that the {\tt Theta} property is properly set for your application, see \ltr{p\_shell}{setTheta}.\\
%
 \rz\ts{SelFaceNeg} & same behavior as \ts{SelFace} but flips elements so that the normal direction is reversed. Face identifiers are then defined with the same numbering but with negative values. This allows selecting volume skins oriented with inward normals, ad also allows genereting dedicated orientations on shell elements. To be consistent token \ts{SelFacePos} is also detected and behaves as \ts{SelFace}.\\
%
\end{tabular}

\begin{SDT}
\lvs \begin{tabular}{@{}p{.2\textwidth}@{}p{.8\textwidth}@{}}
\rz\ts{SelFace -trim }\tsi{val} & trims a surface selection to remove boundary elements that may overcome a sharp edge. The base application is thus to be able to select interior surfaces with robustness regarding the surface edges in a volume, where it is classical to end up with a layer of side elements. The sharp edges detection uses \ltr{feutilb}{SurfaceAsQuad} to whom the angle defined by \tsi{val} is passed. Sharp edge element groups exclusively containing elements with nodes on the edge of the surface are then removed from the selection. \\
\end{tabular}
\end{SDT}

Different selectors can be chained using the available logical operations
\begin{itemize}
\item \ts{\&} finds elements that verify both conditions.
\item \ts{|} finds elements that verify one or both conditions.
\item \ts{\&\~\ } finds elements that verify the left condition and not the right condition (exclusion from current selection state)
\end{itemize}
{\tt i1=feutil('FindEltGroup 1:3 \& with node 1 8',model)} for example. Condition combinations are always evaluated from left to right (parentheses are not accepted). Note that \ts{SelEdge} and \ts{SelFace} selectors do not output elements of the mesh but new elements of respectively 1D or 2D topology, so that some combinations may not be directly possible ({\it e.g.} if later combined to \ts{Group} selector).

Command option \ts{epsl} \tsi{value} can be used to give an evaluation tolerance for equality logical operators.

Numeric values to the command can be given as additional arguments. Thus the command above could also have been written {\tt i1=feutil('findelt group \& withnode',model,1:3,[1 8])}.


%----------------------------------------------------------------------------
\csection{Defining fields trough tables, expressions, ...}{VectFromDir}

Finite element fields are used in four main formats

\begin{itemize}
\item  \hyperlink{def}{\tt def} field at DOFs
\item \ltt{InfoAtNode} field at nodes of an element group can be built from a \htt{pro.MAP} field which can be an {\tt VectFromDir} structure,  a structure with fields {\tt .bas} and {.EltId} with {\tt EltId=0} to define material orientations.  \\
 \ts{info,EltOrient} is an alternative to specify the orientation of all elements rather than associate values for each property entry. The format is a structure with field {\tt .EltId} giving the identifiers and {\tt .bas} giving an orientation for each element in the \basis\ format. To interpolate constitutive properties as a function of temperature, ... see \ser{pl}. \index{EltOrient}  
\item \ltt{gstate} field at integration points of an element group (can be built from a {\tt pro.gstate} field).
\item a field definition structure to be transformed to the other formats using a {\tt elem0('VectFromDir')} command as illustrated below.
\end{itemize}

The {\tt VectFromDir} structure has fields

\lvs\noindent\begin{tabular}{@{}p{.15\textwidth}@{}p{.85\textwidth}@{}}
\rz{\tt data.dir}  &  a cell array specifying the value of various fields.
Each cell of {\tt data.dir} can give a constant value, a position dependent value defined by a string \ts{FcnName} that is evaluated using \\ 
& {\tt fv(:,jDir)=eval(FcnName)} or {\tt fv(:,jDir)=feval(FcnName,node)} if the first fails. Note that {\tt node} corresponds to nodes of the model in the global coordinate system and you can use the coordinates \ts{x,y,z} for your evaluation.
 \\
\rz{\tt data.lab}  &  cell array giving label for each field of an {\tt InfoAtNode} or {\tt gstate} structure.\\
\rz{\tt data.DOF}  &  a vector defining the DOF associated with each {\tt .dir} entry. The transformation to a vector defined at {\tt model.DOF} is done using {\tt vect=elem0('VectFromDirAtDof',model,data,model.DOF)}. \\
%
\end{tabular}


For example 

%begindoc
\begin{verbatim}
 % Analytical expression for a displacement field
 model=femesh('testubeam');
 data=struct('dir',{{'ones(size(x))','y','1*x.^3'}}, ...
    'DOF',[.01;.02;.03]);
 model.DOF=feutil('GetDOF',model);
 def=elem0('VectFromDirAtDof',model,data,model.DOF)

 % Orientation field at nodes
 data=struct('dir',{{'x./sqrt(x.^2+y.^2)','y./sqrt(x.^2+y.^2)',0}}, ...
    'lab',{{'v1x','v1y','v1z'}});
 pro=struct('il',1,'type','p_solid','MAP',data);
 model=stack_set(model,'pro','WithMap',pro);
 C1=fe_mknl('init',model);InfoAtNode=C1.GroupInfo{7}
 feplot(model);fecom('showMap','WithMap') % display map

 % Material field at node
 sdtweb('_eval','d_mesh.m#RVEConstitInterp')
\end{verbatim}%enddoc

%---------------------------------------------------------------------------
\newpage\csection{Constraint and fixed boundary condition handling}{mpc}

\subsection{Theory and basic example}

\rigid\ links, {\tt FixDof}, {\tt MPC} entries, symmetry conditions, continuity constraints in CMS applications, ... all lead to problems of the form

\begin{eqsvg}{mpc1}
  \ba{c} \ma{Ms^2+Cs+K}\ve{q(s)}=\ma b \ve{u(s)}\\
   \ve{y(s)}= \ma c \ve{q(s)} \\
   \ma{c_{int}}\ve{q(s)}=0 \ea
\end{eqsvg}

The linear constraints $\ma{c_{int}}\ve{q(s)}=0$ can be integrated into the problem using Lagrange multipliers or constraint elimination. Elimination is done by building a basis $T$ for the kernel of the constraint equations, that is such that
\begin{eqsvg}{mpc_2}
  \textrm{range}(\ma{T}_{N\times (N-NC)})=\textrm{ker}(\ma{c_{int}}_{NS \times N})
\end{eqsvg}
%
Solving problem 
%
\begin{eqsvg}{mpcelim}
  \ba{c} \ma{T^TMTs^2+T^TCTs+T^TKT}\ve{q_R(s)}=\ma{T^Tb} \ve{u(s)}\\
   \ve{y(s)}= \ma{cT} \ve{q_R(s)} \ea
\end{eqsvg}
%
is then strictly equivalent to solving~\eqr{mpc1}. 

The basis $T$ is generated using {\tt [Case,NNode,model.DOF]=fe\_case(model,'gett')} where {\tt Case.T} gives the $T$ basis and {\tt Case.DOF} describes the active or master DOFs (associated with the columns of $T$), while {\tt model.DOF} or the {\tt Case.mDOF} field when it exists, describe the full list of DOFs. \index{degree of freedom (DOF)!master} 

The \httts{NoT} command option controls the need to return matrices, loads, ... in the full of unconstrained DOFs $\ma{M}, \ve{b}$ ... or constrained $T^TMT, T^Tb$ in \femknl, \feload, ... \index{NoT}.

For the two bay truss example, can be written as follows : 

%begindoc
\begin{verbatim}
 model = femesh('test 2bay');
 model2=fe_case(model, ...         % defines a new case
   'FixDof','2-D motion',[.03 .04 .05]', ...  % 2-D motion
   'FixDof','Clamp edge',[1 2]');             % clamp edge
 Case=fe_case('gett',model)  % Notice the size of T and 
 fe_c(Case.DOF)                % display the list of active DOFs
 model = fe_mknl(model)
 
 % Now reassemble unconstrained matrices and verify the equality
 % of projected matrices
 [m,k,mdof]=fe_mknl(model,'NoT');

 norm(full(Case.T'*m*Case.T-model.K{1}))
 norm(full(Case.T'*k*Case.T-model.K{2}))
\end{verbatim}%enddoc

To compute resultants associated with constraint forces further details are needed. One separates active DOF $q_a$ which will be kept and slave DOF that will be eliminated $q_e$ so that the constraint is given by
%
\begin{eqsvg}{mpc_4}
  \ma{c_a\ \  c_e}_{N\times N_e}\ve{\ba{c}q_a\\ q_e\ea}=0 \ \Leftrightarrow \  \ma{-(-c_e^{-1}c_a)\ \  I}\ve{\ba{c}q_a\\ q_e\ea}=\ma {-G \ I} \ve{q} = 0
\end{eqsvg}
%
The subspace with DOFs eliminated is spanned by
%
\begin{eqsvg}{mpc_5}
 \ma{T}_{N\times (N-N_e)}= \ma{\ba{c} I_{(N-N_e)\times (N-N_e)} \\ G_{N_e\times (N-N_e)}\ea} =  \ma{\ba{c}I \\ -c_e^{-1}c_a\ea}
\end{eqsvg}
%
The problem that verifies constraints can also be written using Lagrange multipliers, which leads to 
%
\begin{eqsvg}{mpc_6}
\ma{\ba{cc} \ma{Z(s)} & \ma{\ba{c} -G \\ I \ea}  \\
  \ma{-G \ I}  & 0 \ea} \ve{\ba{c} q \\ F_c\ea} =   \ve{\ba{c} F \\ 0 \ea}
\end{eqsvg}
%
The response can be computed using elimination (equation \eqr{mpcelim}) and the forces needed to verify the constraints (resultant forces) can be assumed to be point forces associated with the eliminated DOF $q_e$ which leads to 
%
\begin{eqsvg}{mpc_7}
 F_c = \ma{\ma{Z_{ea}(s)}+Z_{ee}(s) \ma{G}} \ve{q} -F_e = \ma{T_e^T Z(s) T}\ve{q_a}-T_e^TF
\end{eqsvg}

A common approximation is to ignore viscous and inertia terms in the resultant, that is assume $T_e^T Z(s) T\approx T_e^T K T$. 

\subsection{Local coordinates} %- - - - - - - - - - - - - - - - - - - - - - -

In the presence of local coordinate systems (non zero value of {\tt DID} in node column 3), the {\tt Case.cGL} matrix built during the \ts{gett} command, gives a local to global coordinate transformation

\begin{eqsvg}{mpc_8}
  \ve{q_{all,global}} = \ma{c_{GL}} \ve{q_{all,local}}
\end{eqsvg}

Constraints ({\tt mpc, rigid, ...}) are defined in local coordinates, that is they correspond to
%
\begin{eqsvg}{mpc_9}
  \ve{q_{all,local}} = \ma{T_{local}} \ve{q_{master,local}}
\end{eqsvg}
%
with $q_{master,local}$ master DOFs (DOFs in {\tt Case.DOF}) defined in the local coordinate system and the {\tt Case.T} corresponding to
%
\begin{eqsvg}{mpc_10}
  \ve{q_{all,global}}  = \ma{T}\ve{q_{master,local}} = \ma{c_{GL}}\ma{T_{local}} \ve{q_{master,local}}
\end{eqsvg}
%
As a result, model matrices before constraint elimination (with \ts{NoT}) are expected to be defined in the global response system, while the projected matrix $T^TMT$ are defined in local coordinates. 

\celas\ use local coordinate information for their definition. \cbush\ are defined in global coordinates but allow definition of orientation through the element {\tt CID}. 

An example of rigid links in local coordinates can be found in {\tt se\_gimbal('ScriptCgl')}.\\


\begin{SDT}
This built-in implementation may be impractical in practice as this generates a resolution in the local frame and a response in the global frame. It is thus not conforming to another classical formalism where the system is resolved in the global frame and response provided in the local frame.

In practice it is thus not recommended to exploit {\tt DID} during analysis. It should only be used as intermediate steps in pre/post procedures.
\begin{itemize}
\item Definition of boundary conditions (linear constraints, imposed displacement, external forces) in a local frame. This allows for user-friendly inputs in some advanced applications. In such application define local frames in the concerned nodes {\tt DID} and define the associated case entries in the local frame. {\tt DofLoad, DofSet, MPC, FixDOF, RBE3, rigid, SensDOF} entries are supported. Use function \ltr{feutilb}{CaseL2G} to resolve the case in the global frame before running simulations. This operation removes {\tt DID} entries and stores the $\ma{c_{GL}}$ matrix in the model stack.
\item Recovery of displacement response in a local basis. The {\tt DID} implementation does not allow this. You can build the local to global matrix using \ltr{basis}{trans} command combined with {\tt DID} definition in a dedicated {\tt Node} matrix. If \ltr{feutilb}{CaseL2G} was previously used, the $\ma{c_{GL}}$ matrix is stored in model stack entry {\tt curve,OLDcGL}. Simply transform the response by using the stored matrix transpose.
\end{itemize}

The following structural elements support {\tt DID} definition, \rigid, \celas and \massb.\\
\rigid elements are treated as a case entry.\\
\celas and \massb elements are projected in the globla frame. Command \ltr{feutilb}{CaseL2G} will thus assemble them into a coupling superelement prior to removing {\tt DID} entries.
Few elements support {\tt DID} providing elements matrices directly in the global frame, \celas and \massb elements.

\end{SDT}

%\begin{verbatim}
%\end{verbatim}

\subsection{Enforced displacement} %- - - - - - - - - - - - - - - - - - - - - -


For a {\tt DofSet} entry, one defines the enforced motion in {\tt Case.TIn} and associated DOFs in {\tt Case.DofIn}. The DOFs specified in {\tt Case.DofIn} are then fixed in {\tt Case.T}.


\subsection{Resolution as MPC and penalization transformation} %- - - - - - - - - - - - - - - - - - - - - -

Whatever the constraint formulation it requires a transformation into an explicit multiple point constraint during the resolution. This transformation is accessible for \lts{fe\_case}{RBE3} and \rigid constraints, a cleaned resolution of \lts{fe\_case}{MPC} constraints is also accessible using \fempc.

\begin{itemize}
\item \ts{RBE3c} provides the resolution for \lts{fe\_case}{RBE3} constraints.
\item \ts{RigidC} provides the resolution for \rigid constraints.
\item \ts{MPCc} provides the resolution for \lts{fe\_case}{MPC} constraints.
\end{itemize}

The output is of the format struct with fields

\begin{itemize}
\item {\tt c} the constraint matrix.
\item {\tt DOF} the DOF vector relative to the constraint.
\item {\tt slave} slave DOF indices in {\tt DOF}.
\end{itemize}

Such format allows the user to transform a constraint into a penalization using the constraint matrix as an observation matrix. One can indeed introduce for each constraint equation a force penalizing its violation through a coefficient {\tt kc} so that $\ve{f}_{penal} = kc \ma{c}_{N_c \times N} \ve{q}_{N \times 1}$. This can be written by means of a symmetric stiffness matrix $\ma{k_{penal}}_{N \times N} = kc \ma{c}^T \ma{\mathcal{I}}_{N_c \times N_c} \ma{c}_{N_c \times N}$ added to the system stiffness.


%begindoc
\begin{verbatim}
% Transformation of a constraint into a penalty
% Generation of a screw model example
model=demosdt('demoscrew layer 1 40 20 3 3 space .2 layer 2 40 20 4');
% Model a screw connection with a RBE3 constraint
% see sdtweb fe_case.html#ConnectionScrew
r1=struct('Origin',[20 10 0],'axis',[0 0 1],'radius',3, ...
 'planes',[0 0 111 1 0;3 0 111 1 0;   % [z0 type ProId zTol rTol]
           5.2 0 112 1 6; 7.2 0 112 1 6], ...
 'MatProId',[101 101],'rigid',[Inf abs('rigid')],'NewNode',0);
r1.planes(:,2)=1; % RBE3
mo2=fe_caseg('ConnectionScrew',model,'screw1',r1);
% display the connection in feplot
cf=feplot(mo2);fecom('colordatamat -alpha .1');

% Replace RBE3 by a penalized coupling
% Get the constraint matrix
r1=fe_mpc('rbe3c',mo2,'screw1');
% remove the RBE3 constraint
mo2=fe_case(mo2,'reset');
% Generate the penalization stiffness with default kc
kc=sdtdef('kcelas');
SE=struct('DOF',r1.DOF,'Opt',[1;1],...
 'K',{{feutilb('tkt',r1.c,kc*speye(length(r1.slave)))}});
% Instance the superelement in the model
mo2=fesuper('seadd -unique 1 1 screw1',mo2,SE,[1 1]);

% Compute the system modes
def=fe_eig(cf.mdl,[5 20 1e3]);
\end{verbatim}%enddoc


\subsection{Low level examples} %- - - - - - - - - - - - - - - - - - - - - - -


A number of low level commands (\ltr{feutil}{GetDof}, \lts{feutil}{FindNode}, ...) and functions \fec\ can be used to operate similar manipulations to what \fecase\ \ts{GetT} does, but things become rapidly complex. For example

\begin{verbatim}
% Low level handling of constraints
 femesh('reset'); model = femesh('test 2bay');
 [m,k,mdof]=fe_mknl(model)

 i1 = femesh('findnode x==0');
 adof1 = fe_c(mdof,i1,'dof',1);             % clamp edge
 adof2 = fe_c(mdof,[.03 .04 .05]','dof',1); % 2-D motion
 adof = fe_c(mdof,[adof1;adof2],'dof',2); 

 ind = fe_c(model.DOF,adof,'ind');
 mdof=mdof(ind); tmt=m(ind,ind); tkt=k(ind,ind);
\end{verbatim}

Handling multiple point constraints (rigid links, ...) really requires to build a basis $T$ for the constraint kernel. For rigid links the obsolete \rigid\ function supports some constraint handling. The following illustrates restitution of a constrained solution on all DOFs

\begin{verbatim}
% Example of a plate with a rigid edge
model=femesh('testquad4 divide 10 10');femesh(model)

% select the rigid edge and set its properties
femesh(';selelt group1 & seledge & innode {x==0};addsel');
femesh('setgroup2 name rigid');
FEelt(femesh('findelt group2'),3)=123456;
FEelt(femesh('findelt group2'),4)=0;
model=femesh;

% Assemble
model.DOF=feutil('getdof',model);% full list of DOFs
[tmt,tkt,mdof] = fe_mknl(model); % assemble constrained matrices
Case=fe_case(model,'gett');      % Obtain the transformation matrix

[md1,f1]=fe_eig(tmt,tkt,[5 10 1e3]); % compute modes on master DOF

def=struct('def',Case.T*md1,'DOF',model.DOF) % display on all DOFs
feplot(model,def); fecom(';view3;ch7')
\end{verbatim}




%----------------------------------------------------------------------------
\csection{Internal data structure reference}{elem00}

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\cssection{Element functions and C functionality}{elem0c}

\begin{center}
\intex{95}{fe_arch}
\end{center}

In {\sl OpenFEM}, elements are defined by element functions. Element functions provide different pieces of information like geometry, degrees of freedom, model matrices, \ldots

OpenFEM functions like the preprocessor \femesh, the model assembler \femk\ or the post-processor \feplot\ call element functions for data about elements.

For example, in the assembly step, \femk\ analyzes all the groups of elements. For each group, \femk\ gets its element type ({\sl bar1}, {\sl hexa8}, \ldots) and then calls the associated element function.\\
First of all, \femk\ calls the element function to know what is the right call form to compute the elementary matrices ({\tt eCall=elem0('matcall')} or {\tt eCall=elem0('call')}, see section \ref{elementinfo} for details). {\tt eCall} is a string. Generally, {\tt eCall} is a call to the element function. Then for each element, \femk\ executes {\tt eCall} in order to compute the elementary matrices. 

This automated work asks for a likeness of the element functions, in particular for the calls and the outputs of these functions. Next section gives information about element function writing.

% Element functions providing the functionality described here are seamlessly integrated into the preprocessor \femesh, model assembler \femk\ and post-processor \feplot.  These and other functions call element functions for data about the element (geometry, 
%degrees of freedom, model matrices, etc.).

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\cssection{Standard names in assembly routines}{enames}


\lvs\noindent\begin{tabular}{@{}p{.15\textwidth}@{}p{.85\textwidth}@{}}

\rz {\tt cEGI} & vector of element property row indices of the current element group (without the group header)\\

\rz\ltt{constit} & real ({\tt double}) valued constitutive information. The {\tt constit} for each group is stored in {\tt Case.GroupInfo\{jGroup,4\};}. \\

\rz{\tt def.def} & vector of deformation at DOFs. This is used for non-linear, stress or energy computation calls that need displacement information. \\

\rz {\tt EGID} & Element Group Identifier of the current element group (different from {\tt jGroup} if an EGID is declared).\\

\rz{\tt elt} &  model description matrix. The element property row of the current element is given by {\tt elt(cEGI(jElt),:)} which should appear in the calling format {\tt eCall} of your element function. \\

\rz{\tt ElemF} & name of element function or name of superelement\\

\rz{\tt ElemP} & parent name (used by \femesh\   in particular to allow property inheritance) \\

\rz\ltt{gstate} & real ({\tt double}) valued element state information. \\

\rz\ltt{integ} & {\tt int32} valued constitutive information.  \\

\rz{\tt jElt} & number of the current element in {\tt cEGI}\\

\rz {\tt jGroup} & number of the current element group (order in the element matrix). {\tt [EGroup,nGroup]=getegroup(elt);} finds the number of groups and group start indices. \\

\rz \ltt{nodeE} & nodes of the current element. In the compiled functions, {\tt NodeId} is stored in column 4, followed by the values at each node given in the \ltt{InfoAtNode}. The position of known columns is identified by the {\tt InfoAtNode.lab} labels (the associated integer code is found with {\tt comstr('lab',-32)}). Of particular interest are 

\begin{itemize}
\item {\tt v1x} (first vector of material orientation, which is assumed to be followed by {\tt v1y,v1z} and for 3D orientation {\tt v2x,y,z}), see stack entry {\tt info,EltOrient}
\item {\tt v3x,v3y,v3z} for normal maps
\item {\tt T} is used for temperature (stack entry {\tt info,RefTemp}) 
\end{itemize}
\end{tabular}

\lvs\noindent\begin{tabular}{@{}p{.15\textwidth}@{}p{.85\textwidth}@{}}


\rz \htt{NNode} & node identification reindexing vector. {\tt NNode(ID)} gives the row index (in the {\tt node} matrix) of the nodes with identification numbers  {\tt ID}. You may use this to extract nodes in the {\tt node} matrix using something like {\tt node(NNode(elt(cEGI(jElt),[1 2])),:)} which will extract the two nodes with numbers given in columns 1 and 2 of the current element row (an error occurs if one of those nodes is not in {\tt node}). 
 This can be built using {\tt NNode=sparse(node(:,1),1,1:size(node,1)}.\\
\rz\ltt{pointers} & one column per element in the current group gives. \\
\end{tabular}

\noindent\begin{tabular}{@{}p{.15\textwidth}@{}p{.85\textwidth}@{}}
%
%
\end{tabular}

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\cssection{Case.GroupInfo cell array}{GroupInfo}\index{data structure!GroupInfo}

\index{Case.GroupInfo}The meaning of the columns of {\tt GroupInfo} is as follows

{\tt DofPos Pointers Integ Constit gstate ElMap InfoAtNode EltConst}


\lvs\noindent\begin{tabular}{@{}p{.15\textwidth}@{}p{.85\textwidth}@{}}
%
\rz\htt{DofPos} & \rz{\tt int32} matrix whose columns give the DOF positions in the full matrix of the associated elements. Numbering is C style (starting at 0) and -1 is used to indicate a fixed DOF.\\

\rz\htt{pointers} & \rz{\tt int32} matrix whose columns describe information each element of the group. Pointers has one column per element giving \par
 {\tt [OutSize1 OutSize2 u3 NdNRule MatDes IntegOffset ConstitOffset  StateOffset u9 u10]} 

{\tt Outsize1} size of element matrix (for elements issued from MODULEF), zero otherwise. 


{\tt MatDes} type of desired output. See the \lts{fe\_mknl}{MatType} section for a current list. 

{\tt IntegOffset} gives the starting  index (first element is 0) of integer options for the current element in \ltt{integ}. 

{\tt ConstitOffset} gives the starting  index (first element is 0) of real options for the current element in {\tt constit}. 

\end{tabular}


\lvs\noindent\begin{tabular}{@{}p{.15\textwidth}@{}p{.85\textwidth}@{}}
\rz\htt{integ} & \rz{\tt int32} matrix storing integer values used to describe the element formulation of the group. Meaning depends on the problem formulation and should be documented in the property function (\psolid\ \ts{BuildConstit} for example).

The nominal content of an {\tt integ} column (as return by the element {\tt integinfo} call) is \par

{\tt MatId,ProId,NDofPerElt,NNodePerElt,IntegRuleType}

where \integrules{\tt (ElemP,IntegRuleType)} is supposed to return the appropriate integration rule.\\
\rz\htt{constit}  & \rz{\tt double} matrix storing integer values used to describe the element formulation of the group. Meaning depends on element family and should be documented in the element property function (\psolid\ \ts{BuildConstit} for example).\\

\rz\htt{gstate}& a curve with field {\tt .Y} describing the internal state of each element in the group. Typical dimensions stress, integration points, elements so that {\tt .Y} has size $Nstrain\times Nw \times NElt$. The labels in {\tt .X\{1\}} can be used to find positions in the {\tt .Y} matrix. The {\tt .X\{2\}} should contain the gauss point locations within the reference element. Automated generation of initial states is discussed in \ser{VectFromDir}. \\ 
& Users are of course free to add any appropriate value for their own elements, a typical application is the storage of internal variables. For an example of {\tt gstate} initialization see \festress\ thermal. \\ 
& the old format with a {\tt double} matrix with one column per element is still supported but will be phased out. \\

\rz\htt{ElMap} & \rz{\tt int32} element map matrix used to distinguish between internal and external element DOF numbering (for example : {\tt hexa8} uses all $x$ DOF, then all $y$ ... as internal numbering while the external numbering is done using all DOFs at node 1, then node 2, ...). The element matrix in external sort is given by {\tt k\_ext=ke(ElMap)}. 
{\tt EltConst.VectMap} gives similar reordering information for vectors (loads, ...).
 \\
\rz\htt{InfoAtNode} & a structure with {\tt .NodePos (int32)} with as many columns as elements in the group giving column positions in a {\tt .data} field. Each row in {\tt .data} corresponds to a field that should be described by a cell array of string in {\tt .lab} used to identify fields in assembly, see \ltt{nodeE}. Initialization for a given element type is done the \ts{GroupInit} phase, which uses \ltt{pro.MAP} fields (see \ser{VectFromDir}). Typical labels for orientation are {\tt \{'v1x','v1y','v1z','v2x','v2y','v2z'\}}\\
 & Obsolete format : \rz{\tt double} matrix whose {\bf rows} describe information at element nodes (as many columns as nodes in the model). \\
\rz{\tt EltConst} & \rz{\tt struct} used to store element formulation information (integration rule, constitutive matrix topology, etc.) Details on this data structure are given in \ser{eltconst}.  \\
\end{tabular}

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\cssection{Element constants data structure}{eltconst}\index{data structure!element constants}

The \htt{EltConst} data structure is used in most newer generation elements implemented in {\tt of\_mk.c}. It contains geometric and integration rule properties. The shape information is generated by calls to \integrules. The formulation information is generated {\tt p\_function const} calls (see \psolid, \pheat, ...).

\vs\noindent\begin{tabular}{@{}p{.15\textwidth}@{}p{.85\textwidth}@{}}
%
\rz{\tt .N} & $nw \times Nnode$ shape functions at integration points\\
\rz{\tt .Nr} & $nw \times Nnode$ derivative of shape function with respect to  the first reference coordinate $r$\\
\rz{\tt .Ns} & $nw \times Nnode$ derivative of shape function with respect to  the second reference coordinate $s$\\
\rz{\tt .Nt} & $nw \times Nnode$ derivative of shape function with respect to  the second reference coordinate $t$\\
\rz{\tt .w} & $Nnode \times 4$ gives the $r,s,t$ positions (with $t=0$ for 2D) of Gauss points within the element and the integration rule weight in column 4.\\
\rz{\tt .NDN} & $Nshape \times nw (1+Ndim)$ memory allocation to store the shape functions and their derivatives with respect to physical coordinates $\ma{N\  N,x\  N,y\  N,z}$. {\tt of\_mk} currently supports the following geometry rules {\tt 3} 3D volume, {\tt 2} 2D volume, {\tt 23} 3D surface, {\tt 13} 3D line (see \integrules\ \ts{BuildNDN} for calling formats). Cylindrical and spherical coordinates are not currently supported.  In the case of rule {\tt 31} (hyperelastic elements), the storage scheme is modified to be $(1+Ndim) \times Nshape \times nw$ which preserves data locality better.\\
\rz{\tt .jdet} & $Nw$ memory allocation to store the determinant of the jacobian matrix at integration points. \\
\rz{\tt .bas} & $9\times Nw$ memory allocation to store local material basis. This is in particular used for 3D surface rules where components {\tt 6:9} of each column give the normal. \\
\rz{\tt .Nw} & number of integration points for output (inferior to {\tt size(EltConst.N,1)} when different rules are used inside a single element) \\
\rz{\tt .Nnode} & number of nodes (equal to {\tt size(EltConst.N,2)=size(EltConst.NDN,1)}) \\
\rz{\tt .xi} & $Nnode \times 3$ reference vertex coordinates \\
\rz{\tt .VectMap} & index vector giving DOF positions in external sort. This is needed for RHS computations.\index{VectMap} \\
\rz{\tt .CTable} & low level interpolation of constitutive relation based on field values.  Storage as a double vector is given by {\tt [Ntables CurrentValues (Ntables x 7) tables]} with {\tt CurrentValues} giving {\tt [i1 xi si xstartpos Nx nodeEfield constit(pos\_Matlab)]}. Implementation is provided for \melastic\ to account for temperature dependence, \femat\ to generate interpolated properties.  
\\
%
\end{tabular}

%----------------------------------------------------------------------------
\newpage\csection{Creating new elements (advanced tutorial)}{elem0}%

In this section one describes the developments needed to integrate a new element function into {\sl OpenFEM}. \index{element!function}\index{element!user defined} First, general information about OpenFEM work is given. Then the writing of a new element function is described. And at last, conventions which must be respected are given. 

%----------------------------------------------------------------------------
\cssection{Generic compiled linear and non-linear elements}{mat_og}%

To improve the ease of development of new elements, OpenFEM now supports a new category of generic element functions. Matrix assembly, stress and load assembly calls for these elements are fully standardized to allow optimization and generation of new element without recompilation. All the element specific information stored in the \ltt{EltConst} data structure. 

Second generation volume elements are based on this principle and can be used as examples. These elements also serve as the current basis for non-linear operations.

The adopted logic is to develop families of elements with different topologies. To implement a family, one needs

\begin{itemize}
 \item shape functions and integration rules. These are independent of the problem posed and grouped systematically in \integrules.
 \item topology, formatting, display, test, ... information for each element. This is the content of the \lsec{elementfcn}{element function} (see hexa8, tetra4, ...) .
 \item a procedure to build the {\tt constit} vectors from material data. This is nominally common to all elements of a given family and is used in \ts{integinfo} element call. For example \texline \psolid{\tt ('BuildConstit')}.
 \item a procedure to determine constants based on current element information. This is nominally common to all elements of a given family and is used in {\tt groupinit} phase (see \femk). The {\tt GroupInit} call is expected to generate an \ltt{EltConst} data structure, that will be stored in the last column of {\tt Case.}\ltt{GroupInfo}. For example {\tt hexa8 constants} which calls \texline \psolid{\tt ('ConstSolid')}. 
 \item a procedure to build the element matrices, right hand sides, etc. based on existing information. This is compiled in {\tt of\_mk MatrixIntegration} and 
{\tt StressObserve} commands. For testing/development purposes is expected that for {\tt sdtdef('diag',12)} an {\tt .m} file implementation in {\tt elem0.m} is called instead of the compiled version.
\end{itemize}

The following sections detail the principle for linear and non-linear elements.

\subsection{What is done in the element function} % - - - - - - - - - - - - -

Most of the work in defining a generic element is done in the element property function (for initialization) and the compile {\tt of\_mk} function. You do still need to define the commands

\begin{itemize}
\item {\tt integinfo} to specify what material property function will be called to build {\tt integ}, {\tt constit} and {\tt elmap}. For example, in {\tt hexa8}, the code for this command command is

\begin{verbatim}
 if comstr(Cam,'integinfo')
  %constit integ,elmap                       ID,pl,il
  [out,out1,out2]= ...
   p_solid('buildconstit',[varargin{1};24;8],varargin{2},varargin{3});
\end{verbatim}
%
input arguments passed from {\tt fe\_mknl} are {\tt ID} a unique pair of {\tt MatId} and {\tt ProId} in the current element group. {\tt pl} and {\tt il} the material and element property fields in the model. Expected outputs are {\tt constit}, {\tt integ} and {\tt elmap}, see {\tt Case.}\ltt{GroupInfo}.  Volume elements {\tt hexa8, q4p, ...}  are topology holders. They call {\tt p\_solid BuildConstit} which in turn calls as another property function as coded in the type (column two of {\tt il} coded with {\tt fe\_mat('p\_fun','SI',1)}). When another property function is called, it is expected that {\tt constit(1:2)=[-1 TypeM]} to allow propagation of type information to parts of the code that will not analyze {\tt pl}. 

\item {\tt constants} to specify what element property function will be called to initialize \ltt{EltConst} data structure and possibly set the geometry type information in {\tt pointers(4,:)}. For example, in {\tt hexa8}, the code for this command is

\begin{verbatim}
...
elseif comstr(Cam,'constants') 
  integ=varargin{2};constit=varargin{3};
  if nargin>3; [out,idim]=p_solid('const','hexa8',integ,constit);
  else; p_solid('constsolid','hexa8',[1 1 24 8],[]);return;
  end
  out1=varargin{1};out1(4,:)=idim; % Tell of_mk('MatrixInt') this is IDIM 
...
\end{verbatim}
%
input arguments passed from {\tt fe\_mknl} are {\tt pointers},{\tt integ},{\tt constit} the output arguments are {\tt EltConst} and a modified {\tt pointers} where row 4 is modified to specify a 3D underlying geometry.  

If {\tt constit(1:2)=[-1 TypeM]} {\tt p\_solid} calls the appropriate property function.

For elements that have an internal orientation (shells, beams, etc.) it is expected that orientation maps are built during this command (see {\tt beam1t}, ...). Note, that the {\tt 'info','EltOrient'} stack entry can also be used for that purpose.

\item standard topology information (commands \ts{node}, \ts{dof}, \ts{prop}, \ts{line}, \ts{patch}, \ts{face}, \ts{edge}, \ts{parent}) see~\ser{elementfcn}.
\end{itemize}

{\tt hexa8} provides a clean example of what needs to be done here.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\cssection{What is done in the property function}{p_fcn} 


\rmain{p\_fcn}

Commands specific to {\tt p\_*} are associated to the implementation of a particular physical formulation for all topologies.

\ruic{p\_fun}{BuidConstit}{}

As shown in \ser{elem0c} and detailed under \femknl\ the FEM initialization phase needs to resolve

\begin{itemize}
\item constitutive law information from model constants (\ltr{elem0}{integinfo} call to the element functions, which for all topology holder elements is forwarded to {\tt p\_solid \ts{BuildConstit}})
\item and to fill-in integration constants and other initial state information (using \ts{groupinit} to generate the call and \ts{constant} build the data). 
\end{itemize}

Many aspects of a finite element formulation are independent of the supporting topology. Element property functions are thus expected to deal with topology independent aspects of element constant building for a given family of elements. 

Thus the element \ts{integinfo} call usually just transmits arguments to a property function that does most of the work. That means defining the contents of \ltt{integ} and \ltt{constit} columns. For example for an acoustic fluid, {\tt constit} columns generated by \psolid\ \ts{BuildConstit} contain $\ma{\frac{1}{\rho C^2}\ \ \eta \ \ \frac{1}{\rho}}$. 

Generic elements (\hexah, \qfourp, ...) all call {\tt p\_solid \ts{BuildConstit}}. Depending on the property type coded in column 2 of the current material, {\tt p\_solid} attempts to call the associated {\tt m\_{\ti mat}} function with a \ts{BuildConstit} command. If that fails, an attempt to call {\tt p\_{\ti mat}} is made (this allows to define a new family of elements trough a single {\tt p\_fcn} {\tt p\_heat} is such an example). 

\ltt{integ} nominally contains {\tt MatId,ProId,NDofPerElt,NNodePerElt,IntegRuleNumber}.

\ruic{p\_fun}{Const}{}

Similarly, element constant generation of elements that support variable integration rules is performed for an element family. For example, \psolid\ \ts{const} supports for 3D elastic solids, for 2D elastic solids and 3D acoustic fluid volumes. {\tt p\_heat} supports 2D and 3D element constant building for the heat equation.

Generic elements (\hexah, \qfourp, ...) all use the call \\
{\tt [EltConst,NDNDim] = p\_solid('Const',ElemF, integ, constit)}.\\
User extendibility requires that the user be able to bypass the normal operation of {\tt p\_solid const}. This can be achieved by setting {\tt constit(1)=-1} and coding a property type in the second value (for example {\tt constit(1)=fe\_mat('p\_heat','SI',1)}. The proper function is then called with the same arguments as \psolid.

\rmain{*\_fcn}

Expected commands common to both {\tt p\_*} and {\tt m\_*} functions are the following

\ruic{p\_fun}{Subtype}{}

With no argument returns a cell array of strings associated with each subtype (maximum is 9). With a string input, it returns the numeric value of the subtype. With a numeric input, returns the string value of the subtype. See \melastic\ for the reference implementation.

\ruic{p\_fun}{database}{}

Returns a structure with reference materials or properties of this type. Additional strings can be used to give the user more freedom to build properties.

\ruic{p\_fun}{dbval}{}

Mostly the same as \ts{database} but replaces or appends rows in {\tt model.il} (for element properties) or {\tt model.pl} (for material properties).

\ruic{p\_fun}{PropertyUnitType}{}

{\tt i1=p\_function('PropertyUnitType',SubType)} returns for each subtype the units of each value in the property row (column of pl).

 This mechanism is used to automate unit conversions in \ltr{fe\_mat}{Convert}.

{\tt [list,repeat]=p\_function('PropertyUnitTypeCell',SubType)} returns a cell array describing the content of each column, the units and possibly a longer description of the variable. When properties can be repeated a variable number of times, use the {\tt repeat} (example in \pshell\ for composites). This mechanism is used to generate graphical editors for properties.

Cell arrays describing each subtype give

\begin{itemize}
\item a label. This should be always the same to allow name based manipulations and should not contain any character that cannot be used in field names.
\item  a conversion value. Lists of units are given using {\tt fe\_mat('convertSITM')}. If the unit is within that list, the conversion value is the row number. If the unit is the ratio of two units in the list this is obtained using a non integer conversion value. Thus {\tt 9.004} corresponds to kg/m (9 is kg and 4 is m). 
\item a string describing the unit
\end{itemize}

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\cssection{Compiled element families in of\_mk}{ofmk}

\htt{of\_mk} is the C function used to handle all compiled element level computations. Integration rules and shape derivatives are also supported as detailed in \ltt{BuildNDN}.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\csssection{Generic multi-physic linear elements}{mat_og_lin}

This element family supports a fairly general definition of linear multi-physic elements whose element integration strategy is fully described by an {\tt EltConst} data structure.  {\tt hexa8} and {\tt p\_solid} serve as a prototype element function. Element matrix and load computations are implemented in the {\tt of\_mk.c MatrixIntegration} command with {\tt StrategyType=1}, stress computations in the {\tt of\_mk.c StressObserve} command.

\begin{verbatim}
EltConst=hexa8('constants',[],[1 1 24 8],[]);
integrules('texstrain',EltConst)
EltConst=integrules('stressrule',EltConst);
integrules('texstress',EltConst)
\end{verbatim}

Elements of this family are standard element functions (see \ser{elem0}) and the element functions must thus return \ts{node}, \ts{prop}, \ts{dof}, \ts{line}, \ts{patch}, \ts{edge}, \ts{face}, and \ts{parent} values. The specificity is that all information needed to integrate the element is stored in an {\tt EltConst} data structure that is initialized during the {\tt fe\_mknl \ts{GroupInit}} phase. 

For DOF definitions, the family uses an internal DOF sort where each field is given at all nodes sequentially $1x 2x ... 8x 1y ... 8 y ...$ while the more classical sort by node $1x 1y ... 2x ... $ is still used for external access (internal and external DOF sorting are discussed in \ser{e.dof}).

Each linear element matrix type is represented in the form of a sum over a set of integration points

\begin{eqsvg}{mat_og_lin_1}
 k^{(e)} = \sum_{ji,jj} \sum_{jw}\ma{\ve{B_{ji}} D_{ji\ jk}(w(jw)) \ve{B_{jj}}^T }J(w(jw)) W((jw))
\end{eqsvg}
%
where the jacobian of the transformation from physical $xyz$ to element $rst$ coordinates is stored in {\tt EltConst.jdet(jw)} and the weighting associated with the integration rule is stored in \texline {\tt EltConst.w(jw,4)}.

The relation between the {\tt Case.GroupInfo constit} columns and the $D_{ij}$ constitutive law matrix is defined by the cell array {\tt EltConst.ConstitTopology} entries. For example, the strain energy of a acoustic pressure formulation (\psolid\ \ts{ConstFluid}) is given by 

\begin{center}
\intex{60}{ConstitTopo}
\end{center}


The integration rule for a given element is thus characterized by the strain observation matrix $B_{ji}(r,s,t)$ which relates a given strain component $\epsilon_{ji}$ and the nodal displacements. The generic linear element family assumes that the generalized strain components are linear functions of the shape functions and their derivatives in euclidean coordinates ($xyz$ rather than $rst$).

 The first step of the element matrix evaluation is the evaluation of the {\tt EltConst.NDN} matrix whose first $Nw$ columns store shape functions, $Nw$ next their derivatives with respect to $x$, then $y$ and $z$ for 3D elements
%
\begin{eqsvg}{mat_og_lin_2}
 \ma{NDN}_{Nnode \times {Nw (Ndims + 1)}} = \ma{\ma{N(r,s,t)} \\ \ma{\frac{\partial N}{\partial x}} \ \ma{\frac{\partial N}{\partial y}} \ \ma{\frac{\partial N}{\partial z}}  }
\end{eqsvg}
To improve speed the {\tt EltConst.NDN} and associated {\tt EltConst.jdet} fields are preallocated and reused for the assembly of element groups.

For each strain vector type, one defines an {\tt int32} matrix \par {\tt EltConst.StrainDefinition\{jType\}} with each row describing  {\tt row, NDNBloc, DOF, NwStart, NwTot} giving the strain component number (these can be repeated since a given strain component can combine more than one field), the block column in NDN (block 1 is $N$, 4 is $\partial N/\partial z$, a negative number can be used to specify $-N$, ...), the field number, and the starting integration point associated with this strain component and the number of integration points needed to assemble the matrix. The default for {\tt NwStart NwTot} is {\tt 1, Nw} but this formalism allows for differentiation of the integration strategies for various fields. The figure below illustrates this construction for classical mechanical strains.

\vspace*{.5cm}
\intex{95}{StrainDef}

To help you check the validity of a given rule, you should fill the \par {\tt EltConst.StrainLabels\{jType\}} and {\tt EltConst.DofLabels} fields and use the\\ {\tt integrules( 'texstrain', EltConst)} command to generate a LATEX printout of the rule you just generated.

The {\tt .StrainDefinition} and {\tt .ConstitTopology} information is combined automatically in \integrules\ to generate {\tt .MatrixIntegration} ({\tt integrules \ts{MatrixRule}} command) and {\tt .StressRule} fields ({\tt integrules \ts{StressRule}} command). These tables once filed properly allow an automated integration of the element level matrix and stress computations in OpenFEM.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
\subsubsection{Phases in of\_mk.c matrix integration} 

The core of element computations is the \ts{matrixintegration} command that computes and assembles a group of elements.

After a number of inits, one enters the loop over elements. 

The \htt{nodeE} matrix, containing {\em field at element nodes}, is filled with information at the element nodes as columns. The first 3 columns are positions. Column 4 is reserved for node numbers in case a callback to MATLAB makes use of the information. The following columns are based on the \ltt{InfoAtNode} structure whos indexing strategy is compatible with both continuous and discontinuous fields at each node. See \swref{elem0('get\_nodeE')} for details.

Initialization of {\tt InfoAtNode} is performed with \femknl{\tt ('Init -gstate')} calls. The {\tt m\_elastic} \ts{AtNodeGState} command is an illustration of init used to interpolate material properties in volume elements.

The \htt{defe} vector/matrix contains the values at the current element DOF of the provided deformation(s).

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
\subsubsection{Generic RHS computations\label{rhs_og}} 

Right hand side (load) computations can either be performed once (fixed set of loads) through {\tt fe\_load} which deals with multiple loads, or during an iterative process where a single RHS is assembled by \femknl\ into the second column of the state argument  {\tt dc.def(:,2)} along with the matrices when requiring the stiffness with {\tt MatDes=1} or {\tt MatDes=5} (in the second case, the forces are assumed following if implemented).


 There are many classical forms of RHS, one thus lists here forms that are implemented in {\tt of\_mk.c MatrixIntegration}. Computations of these rules, requires that the \ltt{EltConst}{\tt .VectMap} field by defined. Each row of {\tt EltConst.RhsDefinition} specifies the procedure to be used for integration. 

Two main strategies are supported where the fields needed for the integration of loads are stored either as columns of {\tt dc.def} (for fields that can defined on DOFs of the model) or as \ltt{nodeE} columns.

Currently the only accepted format for rows of {\tt EltConst.RhsDefinition} is 

 {\tt    101(1) InfoAtNode1(2) InStep(3) NDNOff1(4)  FDof1(5) NDNCol(6) \\ NormalComp(7) w1(8) nwStep(9)}

Where {\tt InfoAtNode1} gives the first row index in storing the field to be integrated in {\tt InfoAtNode}. {\tt InStep} gives the index step (3 for a 3 dimensional vector field), {\tt NDNOff1} gives the block offset in the NDN matrix (zero for the nominal shape function). {\tt FDof1} gives the offset in force DOFs for the current integration. {\tt NDNCol}. If larger than {\tt -1}, the normal component {\tt NormalComp} designs a row number in {\tt EltConst.bas}, which is used as a weighting coefficient. {tt w1} gives the index of the first Gauss point to be used (in C order starting at 0). {\tt nwStep} gives the number of Gauss points in the rule being used.

\begin{itemize}
\item volume forces not proportional to density

\begin{eqsvg}{rhs_og_1}
 \int_{\Omega_0} f_v(x) . du(x) = \ve{F_v}_k = \sum_{j_w} \br{\ve{N_k(j_w)} \ve{N_j(j_w)} f_v(x_j) } J(j_w) W(j_w)
\end{eqsvg}

are thus described by 

\begin{verbatim}
 opt.RhsDefinition=int32( ...
   [101 0 3 0     0 0 -1    rule+[-1 0];
    101 1 3 0     1 0 -1    rule+[-1 0];
    101 2 3 0     2 0 -1    rule+[-1 0]]);
\end{verbatim}

for 3D solids (see \psolid). 

Similarly, normal pressure is integrated as 3 volume forces over 3D surface elements with normal component weighting

\begin{eqsvg}{rhs_og_2}
 \ba{ccc} F_m & = & \int_{\partial \Omega_0} p(x) n_m(x)  . dv(x)\\ &=&  \sum_{j_w} \br{\ve{N_k(j_w)} \ve{N_j(j_w)} p(x_j) n_m} J(j_w) W(j_w)\ea
\end{eqsvg}


\item inertia forces (volume forces proportional to density)

\begin{eqsvg}{rhs_og_3}
 F= \int_{\Omega_0} \rho(x) f_v(x) . dv(x)
\end{eqsvg}

\item stress forces (will be documented later)

\end{itemize}

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
\csssection{Large transformation linear elasticity}{Elas3DNL} 


{\tt Elastic3DNL} fully anisotropic elastic elements in geometrically non-linear mechanics problems. Element matrix are implemented in the {\tt of\_mk.c MatrixIntegration} command with {\tt StrategyType=2} for the linear tangent matrix ({\tt MatType=5}). Other computations are performed using generic elements~(\ser{mat_og_lin}) (mass {\tt MatType=2}). This formulation family has been tested for the prediction of vibration responses under static pre-load.

Stress post-processing is implemented using the underlying linear element.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
\csssection{Hyperelasticity}{HyperElas} 


Simultaneous element matrix and right hand side computations are implemented in the {\tt of\_mk.c MatrixIntegration} command with {\tt StrategyType=3} for the linear tangent matrix ({\tt MatType=5}). In this case (and only this case!!), the {\tt EltConst.NDN} matrix is built as follow: \\
for $1\le jw \le Nw$
\begin{eqsvg}{HyperElas_1}
 \ma{NDN}_{(Ndims + 1) \times {Nnode (Nw)}} = \ma{\ma{NDN}^{jw}}
\end{eqsvg}
with
\begin{eqsvg}{HyperElas_2}
 \ma{NDN}^{jw}_{(Ndims + 1) \times {Nnode}} = \ma{\ba{cccc}
\ma{N(r,s,t)}_{jw} \\
\ma{\frac{\partial N}{\partial x}}_{jw} \\
\ma{\frac{\partial N}{\partial y}}_{jw} \\
\ma{\frac{\partial N}{\partial z}}_{jw} \ea }
\end{eqsvg}
This implementation corresponds to {\tt case 31} of NDNSwitch function in {\tt of\_mk\_pre.c}.
The purpose is to use C-BLAS functions in element matrix and right hand side computations implemented in the same file (function {\tt Mecha3DintegH}) to improve speed.

Other computations are performed using generic elements~(\ser{mat_og_lin}) (mass {\tt MatType=2}). This formulation family has been tested for the {\tt RivlinCube} test. 

Stress post-processing is not yet implemented for hyperelastic media.


\subsection{Non-linear iterations, what is done in {\tt of\_mk}} % - - - - - - - - - - - - - - - -

Non linear problems are characterized by the need to perform iterations with multiple assemblies of matrices and right hand sides (RHS). To optimize the performance, the nominal strategy for non-linear operations is to 

\begin{itemize}
\item perform an initialization (standard \ltt{of\_mk}{\tt nl}\ \ts{init} call)
\item define a \hyperlink{def}{deformation data structure} {\tt dc} with two columns giving respectively the current state and the non linear RHS.
\end{itemize}

At a given iteration, one resets the RHS and performs a single {\tt fe\_mknl} call that returns the current non-linear matrix and replaces the RHS by its current value (note that {\tt fe\_mknl} actually modifies the input argument {\tt dc} which is not an normal \matlab\ behavior but is needed here for performance)

\begin{verbatim}
 % at init allocate DC structure
 dc=struct('DOF',model.DOF,'def',zeros(length(model.DOF),2); 
 % ... some NL iteration mechanism here
 dc.def(:,2)=0; % reset RHS at each iteration
 k=fe_mknl('assemble not',model,Case,dc,5); % assemble K and RHS
\end{verbatim}

Most of the work for generic elements is done within the {\tt of\_mk \ts{MatrixIntegration}} command that is called by \femknl. Each call to the command performs matrix and RHS assembly for a full group of elements. Three strategies are currently implemented

\begin{itemize}
\item {\tt Linear} multiphysics elements of arbitrary forms, see~\ser{mat_og_lin}
\item {\tt Elastic3DNL} general elastic elements for large transformation,  see~\ser{Elas3DNL}
\item {\tt Hyperelastic} elements for large transformation problems. see~\ser{HyperElas}. These elements have been tested through the {\tt RivlinCube} example.
\end{itemize}

%----------------------------------------------------------------------------
\cssection{Element function command reference}{elementfcn}

\index{element!function}
Nominally you should write topology independent element families, if hard coding is needed you can however develop new element functions.

In Matlab version, a typical element function is an \ts{.m} or \ts{.mex} file that is in your \matlab\ path. In Scilab version, a typical element function is an \ts{.sci} or \ts{.mex} file that is loaded into Scilab memory (see {\tt getf} in Scilab on-line help).

The name of the function/file corresponds to the name of the element (thus the element \bare\ is implemented through the \ts{bar1.m} file)

\subsubsection{General element information \label{elementinfo}}

To build a new element take \ts{q4p.m} or \ts{q4p.sci} as an example.

  As for all Matlab or Scilab functions, the header is composed 
of a function syntax declaration and a help section. The following example is written for Matlab. For Scilab version, don't forget to replace \verb+%+ by {\tt //}. In this example, the name of the created element is {\tt elem0}. 

For element functions the nominal format is

\begin{verbatim}
 function [out,out1,out2]=elem0(CAM,varargin);
 %elem0 help section
\end{verbatim}

The element function should then contain a section for standard calls which let other functions know how the element behaves.

\begin{verbatim}
 if isstr(CAM) %standard calls with a string command

  [CAM,Cam]=comstr(CAM,1); % remove blanks
  if comstr(Cam,'integinfo')
   % some code needed here
   out= constit; % real parameter describing the constitutive law
   out1=integ;   % integer (int32) parameters for the element
   out2=elmap;   

  elseif comstr(Cam,'matcall')
   out=elem0('call');
   out1=1; % SymFlag
  elseif comstr(Cam,'call');     out = ['AssemblyCall'];
  elseif comstr(Cam,'rhscall');  out = ['RightHandSideCall'];
  elseif  comstr(Cam,'scall');   out = ['StressComputationCall'];
  elseif  comstr(Cam,'node');    out = [NodeIndices]; 
  elseif  comstr(Cam,'prop');    out = [PropertyIndices]; 
  elseif  comstr(Cam,'dof');     out = [ GenericDOF ];
  elseif comstr(Cam,'patch');    
                         out = [ GenericPatchMatrixForPlotting ];
  elseif comstr(Cam,'edge');     out = [ GenericEdgeMatrix ];
  elseif comstr(Cam,'face');     out = [ GenericFaceMatrix ];
  elseif comstr(Cam,'sci_face'); out = [ SciFaceMatrix ];
  elseif comstr(Cam,'parent');   out = ['ParentName'];
  elseif comstr(Cam,'test')
     % typically one will place here a series of basic tests
  end
  return
 end % of standard calls with string command

\end{verbatim}

The expected outputs to these calls are detailed below. 

\csssection{{\tt call,matcall}}{e.call} %   - - - - - - - - - - - - - - - - 

{\sl Format string for element matrix computation call}. Element functions must be able to give \femk\ the proper format to call them (note that superelements take precedence over element functions with the same name, so avoid calling a superelement \beam, etc.).

\ts{matcall} is similar to \ts{call} but used by {\tt fe\_mknl}. Some elements directly call the {\tt of\_mk} mex function thus avoiding significant loss of time in the element function. If your element is not directly supported by {\tt fe\_mknl} use {\tt matcall=elem0('call')}.



 The format of the call is left to the user and determined by 
\femk\ by executing the command {\tt eCall=elem0('call')}. The default for the string {\tt eCall} should be (see any of the existing element functions for an example)

\begin{verbatim}
  [k1,m1]=elem0(nodeE,elt(cEGI(jElt),:),...
                pointers(:,jElt),integ,constit,elmap);
\end{verbatim}

To define other proper calling formats, you need to use the names of a number of variables that are internal to \femk. \femk\ variables used as {\sl output arguments of element functions} are

\vs\noindent\begin{tabular}{@{}p{.15\textwidth}@{}p{.85\textwidth}@{}}
\rz{\tt k1} &  element matrix (must always be returned, for {\tt opt(1)==0} it should be the stiffness, otherwise it is expected to be the type of matrix given by {\tt opt(1)})\\
\rz{\tt m1} & element mass matrix (optional, returned for {\tt opt(1)==0}, see below)
\end{tabular}

\noindent  {\tt [ElemF,opt,ElemP]=\feutil('getelemf',elt(EGroup(jGroup),:),jGroup)} \\ returns, for a given header row, the element function name {\tt ElemF}, options {\tt opt}, and parent name {\tt ElemP}.\ 

\femk\ and {\tt fe\_mknl} variables that can be used as {\sl input arguments to element function} are listed in \ser{enames}.

\csssection{{\tt dof, dofcall}}{e.dof} %   - - - - - - - - - - - - - - - - 

{\sl Generic DOF definition vector}. For user defined elements, the vector returned by {\tt elem0('dof')} follows the usual DOF definition vector format ({\tt NodeId.DofId} or {\tt -1.DofId}) but is generic in the sense that node numbers indicate positions in the element row (rather than actual node numbers) and {\tt -1} replaces the element identifier (if applicable).

For example the \bare\   element uses the 3 translations at 2 nodes whose number are given in position 1 and 2 of the element row. The generic DOF definition vector is thus \texline {\tt [1.01;1.02;1.03;2.01;2.01;2.03]}.

A \ts{dofcall} command may be defined to bypass generic {\tt dof} calls. In particular, this is used to implement elements where the number of DOFs depends on the \hyperlink{il}{element properties}. The command should always return {\tt out=elem0('dofcall');}. The actual DOF building call is performed in {\tt p\_solid('BuildDof')} which will call user {\tt p\_*.m} functions if needed.


Elements may use different DOF sorting for their internal computations. 

\csssection{{\tt edge,face,patch,line,sci\_face}}{e.edge} %   - - - - - - - - -

{\tt face} is a matrix where each row describes the positions in the element row of nodes of the oriented face of a volume (conventions for the orientation are described under \integrules). If some faces have fewer nodes, the last node should be repeated as needed. \feutil\ can consider face sets with orientation conventions from other software.

{\tt edge} is a matrix where each row describes the node positions of the oriented edge of a volume or a surface. If some edges have fewer nodes, the last node should be repeated as needed.

{\tt line} (obsolete) is a vector describes the way the element will be displayed in the line mode (wire frame). The vector is generic in the sense that node numbers represent positions in the element row rather than actual node numbers. Zeros can be used to create a discontinuous line. {\tt line} is now typically generated using information provided by {\tt patch}.


{\tt patch}. In MATLAB version, surface representations of elements are based on the use of \matlab\ {\tt patch} objects. Each row of the generic patch matrix gives the indices nodes. These are generic in the sense that node numbers represent positions in the element row rather than actual node numbers.

\noindent For example the \tetra\ solid element has four nodes in positions {\tt 1:4}. Its generic patch matrix is {\tt [1 2 3;2 3 4;3 4 1;4 1 2]}. Note that you should not skip nodes but simply repeat some of them if various faces have different node counts. 

{\tt sci\_face} is the equivalent of {\tt patch} for use in the SCILAB implementation of {\sl OpenFEM}. The difference between {\tt patch} and {\tt sci\_face} is that, in SCILAB, a face must be described with 3 or 4 nodes. That means that, for a two nodes element, the last node must be repeated (in generality, \verb+sci_face = [1 2 2];+). For a more than 4 nodes per face element, faces must be cut in subfaces. The most important thing is to not create new nodes by the cutting of a face and to use all nodes. For example, 9 nodes quadrilateral can be cut as follows : 
\begin{figure}[H]
\centering
\ingraph{70}{sciface} % [width=12.cm]
 \caption{Lower order patch representation of a 9 node quadrilateral}
\end{figure}
but a 8 nodes quadrilaterals cannot by cut by this way. It can be cut as follows:
\begin{figure}[H]
\centering
\ingraph{70}{sciface2} % [width=12.cm]
 \caption{Lower order patch representation of a 8 node quadrilateral}
\end{figure}


\csssection{integinfo, BuildConstit}{e.integinfo} %   - - - - - - - - - - - - - - - - 

\htr{elem0}{integinfo}, \ts{BuildConstit} are commands to resolve constants in elements and {\tt p\_function} respectively.

\index{integinfo}\index{BuildConstit}{\tt [constit,integ,elmap]=elem0('integinfo',[MatId ProId],pl,il,model,Case)} is supposed to search {\tt pl} and {\tt il} for rows corresponding to {\tt MatId} and {\tt ProId} and return a real vector \ltt{constit} describing the element constitutive law and an integer vector \ltt{integ}. 

\ltt{ElMap} is used to build the full matrix of an element which initially only gives it lower or upper triangular part. If a structure is return, \femknl\ can do some group wise processing (typically initialization of internal states).

In most elements, one uses \texline {\tt [constit,integ,elmap]=p\_solid('buildconstit', [varargin\{1\};Ndof;Nnode],varargin\{2:end\})} since \psolid\ passes calls to other element property functions when needed.

{\tt elmap} can also be used to pass structures and callbacks back to {\tt fe\_mknl}. 

\csssection{{\tt node}}{e.node} %   - - - - - - - - - - - - - - - - 

{\sl Vector of indices} giving the position of nodes numbers in the element row. In general this vector should be {\tt [1:n]} where {\tt n} is the number of nodes used by the element.

\csssection{{\tt prop}}{e.prop} %   - - - - - - - - - - - - - - - - 


\index{MatId}\index{ProId}\index{element!EltID}
{\sl Vector of indices} giving the position of {\tt MatId}, {\tt ProId} and {\tt EltId} in the element row. In general this vector should be {\tt n+[1 2 3]} where {\tt n} is the number of nodes used by the element. If the element does not use any of these identifiers the index value should be zero (but this is poor practice).


\csssection{{\tt parent}}{e.parent} %   - - - - - - - - - - - - - - - - 

{\sl Parent element name}. If your element is similar to a standard element (\beam, \triaa, \quada, \hexah, etc.), declaring a parent allows the inheritance of properties. In particular you will be able to use functions, such as \feload\  or parts of \femesh, which only recognize standard elements.

\csssection{{\tt rhscall}}{e.rhscall} %   - - - - - - - - - - - - - - - - 

{\tt rhscall} is a string that will be evaluated by \feload\ when computing right hand side loads (volume and surface loads). Like \ts{call} or \ts{matcall}, the format of the call is determined by \feload\ by executing the command \verb+eCall=elem0('call')+. The default for the string {\tt eCall} should be : 

\begin{verbatim}
be=elem0(nodeE,elt(cEGI(jElt),:),pointers(:,jElt),...
                        integ,constit,elmap,estate);
\end{verbatim}

The output argument {\tt be} is the right hand side load. The inputs arguments are the same as those for \ts{matcall} and \ts{call}.


%----------------------------------------------------------------------------
\subsubsection{Matrix, load and stress computations}

The calls with one input are followed by a section on element matrix assembly. For these calls the element function is expected to return 
an element DOF definition vector {\tt idof} and an element matrix {\tt k}. The type of this matrix is given in {\tt opt(1)}.  If {\tt opt(1)==0}, both a stiffness {\tt k} and a mass matrix {\tt m} should be returned.  See the \femk\ {\tt MatType} section for a current list. 

Take a look at \bare\ which is a very simple example of element function.

A typical element assembly section is as follows :  

\begin{verbatim}
 % elem0 matrix assembly section

 % figure out what the input arguments are
 node=CAM;   elt=varargin{1}; 
 point=varargin{2};  integ=varargin{3};
 constit=varargin{4}; elmap=varargin{5};
 typ=point(5);
   
 % outputs are [k,m] for opt(1)==0
 %             [mat] for other opt(1)
 switch point(5)
 case 0
  [out,out1] = ... % place stiffness in out and mass in out1
 case 1
   out= ...  % compute stiffness
 case 2
   out= ...  % compute mass
 case 100 
   out= ...  % compute right hand side
 case 200 
   out= ...  % compute stress  ...
 otherwise
   error('Not a supported matrix type');
 end

\end{verbatim}

Distributed load computations (surface and volume) are handled by \feload. Stress computations are handled by \festress.

There is currently no automated mechanism to allow users to integrate such computations for their own elements without modifying \feload\ and \festress, but this will appear later since it is an obvious maintenance requirement.

The mechanism that will be used will be similar to that used for matrix assembly. The element function will be required to provide calling formats when called with {\tt elem0('fsurf')} for surface loads, {\tt elem0('fvol')} for volume loads, and \\ {\tt elem0('stress')} for stresses.  \feload\ and \festress\ will then evaluate these calls for each element.


%----------------------------------------------------------------------------
\input{syntax.tex}  % syntax reference was placed here
%----------------------------------------------------------------------------

%----------------------------------------------------------------------------
\csection{Legacy information}{reflegacy}

This section gives data that is no longer used but is important enough not to be deleted. 

%----------------------------------------------------------------------------
\subsection{Legacy 2D elements}


These elements support isotropic and 2-D anisotropic materials declared with a material entry described in \melastic. Element property declarations are \psolid\ subtype 2 entries

\begin{verbatim}
 [ProId  fe_mat('p_solid','SI',2)  f  N  0]
\end{verbatim}

\noindent Where

\begin{tabular}{@{}p{.15\textwidth}@{}p{.85\textwidth}@{}}
%
\rz{\tt f} & Formulation : {\tt 0} plane stress, {\tt 1} plane strain, {\tt 2} axisymmetric.\\
\rz{\tt N} & Fourier coefficient for axisymmetric formulations\\
\rz{\tt Integ} & set to zero to select this family of elements.\\
\end{tabular}


The $xy$ plane is used with displacement DOFs {\tt .01} and {\tt .02} given at each node. Element matrix calls are implemented using {\tt .c} files called by {\tt of\_mk\_subs.c} and handled by the element function itself, while load computations are handled by \feload. For integration rules, see \ser{of_mk_subs}. The following elements are supported

\begin{itemize}
\item {\tt q4p (plane stress/strain)} uses the {\tt et*2q1d} routines for plane stress and plane strain. 

\item {\tt q4p (axisymmetric)} uses the {\tt et*aq1d} routines for axisymmetry. The radial $u_r$ and axial  $u_z$ displacement are bilinear functions over the element. 


\item {\tt q5p (plane stress/strain)} uses the {\tt et*5noe} routines for axisymmetry.

There are five nodes for this incompressible quadrilateral element, four nodes at the vertices and one at the intersection of the two diagonals.

\item {\tt q8p} uses the {\tt et*2q2c} routines for plane stress and plane strain and {\tt et*aq2c} for axisymmetry.

\item {\tt q9a} is a plane axisymmetric element with Fourier support. It uses  the {\tt e*aq2c} routines to generate matrices.

\item {\tt t3p} uses the {\tt et*2p1d} routines for plane stress and plane strain and  {\tt et*ap1d} routines for axisymmetry.

The displacement (u,v) are assumed to
   be linear functions of (x,y) ({\it{Linear Triangular Element}}),
   thus the strain are constant ({\it{Constant Strain Triangle}}).

\item {\tt t6p}  uses the {\tt et*2p2c} routines for plane stress and plane strain and {\tt et*ap2c} routines for axisymmetry.

\end{itemize}


%----------------------------------------------------------------------------
\cssection{Rules for elements in {\tt of\_mk\_subs}}{of_mk_subs}

\ruic{element}{hexa}{8, hexa20} % - - - - - - - - - - - - - - 

The \hexah\ and \hexav\  elements are the standard 8 node 24 DOF and
20 node 60 DOF brick elements. 

The {\tt hexa8} element uses the {\tt et*3q1d} routines.

{\tt hexa8} volumes are integrated at 8 Gauss points

$\omega_i = {1 \over 8}$ for $i=1,4$ 

$b_i$ for $i=1,4$  as below, with $z=\alpha_{1}$  

$b_i$ for $i=4,8$  as below, with $z=\alpha_{2}$

{\tt hexa8} surfaces are integrated using a 4 point rule

$\omega_i = {1 \over 4}$ for $i=1,4$

$b_1= ( \alpha_{1} , \alpha_{1} ) $ ,
      $b_2= ( \alpha_{2} , \alpha_{1} ) $ ,
      $b_3= ( \alpha_{2} , \alpha_{2} ) $ and
      $b_4= ( \alpha_{1} , \alpha_{2} ) $  

with $ \alpha_{1}= {1 \over 2}-{1 \over {2 \sqrt{3}}}=0.2113249$ and
           $ \alpha_{2}= {1 \over 2}+{1 \over {2 \sqrt{3}}}=0.7886751$.   

The {\tt hexa20} element uses the {\tt et*3q2c} routines.

{\tt hexa20} volumes are integrated at 27 Gauss points $\omega_l = w_i w_j w_k$ for $i,j,k=1,3$ 

with

%$w_1 = w_3 = { 5 \over 18 } $ and $w_2 = { 8 \over 18 } $
%$b_l =  (\alpha_i, \alpha_j, \alpha_k) $  for $i,j,k=1,3$ 
$w_1 = w_3 = \frac{5}{18} $ and $w_2 = \frac{8}{18}  $
$b_l =  (\alpha_i, \alpha_j, \alpha_k) $  for $i,j,k=1,3$ 


with
% $ \alpha_1 = { { 1 - \sqrt{3 \over 5} } \over 2 } $ , $ \alpha_2 = 0.5 $ and 
% $ \alpha_3 = { { 1 + \sqrt{3 \over 5 } } \over 2 } $
%
% $ \alpha_1 = \frac{  1 - \sqrt{\frac{3}{5}} }{2}  $ , $ \alpha_2 = 0.5 $ and 

 $ \alpha_1 = \frac{ 1 - \sqrt{\frac{3}{5}} }{2}  $ , $ \alpha_2 = 0.5 $ and 
 $ \alpha_3 = \frac{ 1 + \sqrt{\frac{3}{5}} }{2}  $

 $ \alpha_1 = \frac{  1 - \sqrt{\frac{3}{5}} }{2}  $ , $ \alpha_2 = 0.5 $ and 

{\tt hexa20} surfaces are integrated at 9 Gauss points $\omega_k = w_i w_j$ for $i,j=1,3$ with

$w_i $ as above and $b_k =  (\alpha_i, \alpha_j) $  for $i,j=1,3$ 

with
%$ \alpha_1 = { { 1 - \sqrt{3 \over 5} } \over 2 } $ , $ \alpha_2 = 0.5 $ and 
%$ \alpha_3 = { { 1 + \sqrt{3 \over 5 } } \over 2 } $.
$ \alpha_1 =  \frac{ 1 - \sqrt{\frac{3}{5}} }{2} $ , $ \alpha_2 = 0.5 $ and 
$ \alpha_3 =  \frac{ 1 + \sqrt{\frac{3}{5}} }{2} $.


\ruic{element}{penta}{6, penta15}  % - - - - - - - - - - - - - - 

The \penta\ and \pentb\ elements are the standard 6 node 18 DOF and 15 node 45 DOF pentahedral elements. A derivation of these elements can be found in \ecite{hug1}.

The {\tt penta6} element uses the {\tt et*3r1d} routines.

{\tt penta6} volumes are integrated at 6 Gauss points

\begin{center}\begin{tabular}{|l|r|r|r|} \hline
Points $b_k$    & $x$   & $y$   & $z$   \\\hline
1               & $a$   & $a$   & $c$   \\ \hline  
2               & $b$   & $a$   & $c$   \\ \hline
3               & $a$   & $b$   & $c$   \\ \hline
4               & $a$   & $a$   & $d$   \\ \hline
5               & $b$   & $a$   & $d$    \\ \hline
6               & $a$   & $b$   & $d$   \\ \hline
\end{tabular}\end{center}

with $a={1 \over 6}=.16667$, $b={4\over6}=.66667$, $c={1 \over 2}-{1 \over {2 \sqrt{3}}}=.21132$, $d= {1 \over 2}+{1 \over {2 \sqrt{3}}}=.78868$

{\tt penta6} surfaces are integrated at 3 Gauss points for a triangular face (see \tetra) and 4 Gauss points for a quadrangular face (see \hexah).

{\tt penta15} volumes are integrated at 21 Gauss points with the 21 points formula

$a= { 9 - 2 \sqrt{15} \over 21 } $, $b= { 9 + 2 \sqrt{15} \over 21 }$, 

$c= { 6 + \sqrt{15} \over 21 }$, $d= { 6 -  \sqrt{15} \over 21 }$, 

$e= 0.5 ( 1 - \sqrt{ { 3 \over 5 } } )$, 

$f= 0.5 $ and $g= 0.5 ( 1 + \sqrt{ { 3 \over 5 } } )$

$\alpha = { 155 - \sqrt{15} \over 2400 } $, $\beta = { 5 \over 18 } $,

$\gamma = { 155 + \sqrt{15} \over 2400 }$, $\delta = { 9 \over 80 } $ 
and $\epsilon = { 8 \over 18 } $.

Positions and weights of the 21 Gauss point are

\begin{center} \begin{tabular}{|l|r|r|r|r|} \hline
Points $b_k$    & $x$   & $y$   & $z$  &  weight $\omega_k$   \\ \hline
1               & $d$   & $d$   & $e$  & $ \alpha.\beta$  \\ \hline
2               & $b$   & $d$   & $e$  & $\alpha.\beta$   \\ \hline
3               & $d$   & $b$   & $e$  & $\alpha.\beta$   \\ \hline
4               & $c$   & $a$   & $e$  & $\gamma.\beta$   \\\hline
5               & $c$   & $c$   & $e$  & $\gamma.\beta$   \\ \hline
6               & $a$   & $c$   & $e$  & $\gamma.\beta$   \\ \hline
7               & ${ 1 \over 3 }$   & ${1 \over 3 }$  & $e$  & $\delta.\beta$   \\ \hline
8               & $d$   & $d$   & $f$  & $\alpha.\epsilon$  \\ \hline
9               & $b$   & $d$   & $f$  & $\alpha.\epsilon$  \\\hline
10               & $d$  & $b$   & $f$  & $\alpha.\epsilon$ \\\hline
11               & $c$  & $a$   & $f$  & $\gamma.\epsilon$ \\\hline
12               & $c$  & $c$   & $f$  & $\gamma.\epsilon$  \\\hline
13               & $a$  & $c$   & $f$  & $\gamma.\epsilon$ \\\hline
14               & ${1 \over 3 }$ & ${ 1 \over 3 }$  & $f$  & $\delta.\epsilon$ \\\hline                                           
15               & $d$  & $d$   & $g$  & $\alpha.\beta$    \\\hline
16               & $b$  & $d$   & $g$  & $\alpha.\beta$    \\\hline
17               & $d$  & $b$   & $g$  & $\alpha.\beta$     \\\hline
18               & $c$  & $a$   & $g$  & $\gamma.\beta$    \\\hline
19               & $c$  & $c$   & $g$  & $\gamma.\beta$     \\\hline
20               & $a$  & $c$   & $g$  & $\gamma.\beta$    \\\hline
21               & ${1 \over 3 }$  & ${ 1 \over 3 }$   & $g$  & $\delta.\beta$    \\\hline                                           
\end{tabular} \end{center}

{\tt penta15} surfaces are integrated at 7 Gauss points for a triangular face (see \tetrb) and 9 Gauss points for a quadrangular face (see \hexav).

\ruic{element}{tetra}{4, tetra10} % - - - - - - - - - - - - - - 

The \tetra\   element is the standard 4 node 12 DOF trilinear isoparametric solid element. {\tt tetra10} is the corresponding second order element.

You should be aware that this element can perform very badly (for poor aspect ratio, particular loading conditions, etc.) and that higher order elements should be used instead. 

The {\tt tetra4} element uses the {\tt et*3p1d} routines.

{\tt tetra4} volumes are integrated at the 4 vertices $\omega_i = {1 \over 4}$ for $i=1,4$ and $b_i=S_i$   the $i$-th element vertex.

{\tt tetra4} surfaces are integrated at the 3 vertices with $\omega_i = {1 \over 3}$ for $i=1,3$ and $b_i=S_i$  the  $i$-th vertex of the actual face

The {\tt tetra10} element is second order and uses the {\tt et*3p2c} routines.

{\tt tetra10} volumes are integrated at 15 Gauss points

\begin {center}
\begin{tabular}{|l|r|r|r|r|r|}
\hline
Points $b_k$    & $\lambda_1$   & $\lambda_2$   & $\lambda_3$  & $\lambda_4$  & weight $\omega_k$   \\
 \hline         
1   & ${ 1 \over 4 }$ & ${ 1 \over 4 }$ & ${1 \over 4 }$ & ${ 1 \over 4 }$ & ${ 8 \over 405} $  \\
 \hline  
2   & $b$    & $a$     & $a$    & $a$    & $\alpha$   \\\hline           
3   & $a$    & $b$     & $a$    & $a$    & $\alpha$   \\\hline
4   & $a$    & $a$     & $b$    & $a$    & $\alpha$   \\\hline           
5   & $a$    & $a$     & $a$    & $b$    & $\alpha$   \\\hline           
6   & $d$    & $c$     & $c$    & $c$    & $\beta$    \\\hline           
7   & $c$    & $d$     & $c$    & $c$    & $\beta$    \\\hline           
8   & $c$    & $c$     & $d$   &  $c$    & $\beta$    \\\hline           
9   & $c$    & $c$     & $c$   &  $d$    & $\beta$    \\\hline           
10      & $e$    & $e$     & $f$   &  $f$    & $\gamma$  \\\hline
11      & $f$    & $e$     & $e$   &  $f$    & $\gamma$  \\\hline          
12      & $f$    & $f$     & $e$   &  $e$    & $\gamma$  \\\hline           
13      & $e$    & $f$     & $f$   &  $e$    & $\gamma$  \\\hline           
14      & $e$    & $f$     & $e$   &  $f$    & $\gamma$  \\\hline           
15      & $f$    & $e$     & $f$   &  $e$    & $\gamma$  \\\hline           
\end{tabular}\end{center}


with $a =  { {7 - \sqrt{15}} \over 34 } = 0.0919711 $ , $ b =  { {13 + 3 \sqrt{15}} \over 34 } = 0.7240868 $ , 
 $c =  { {7 + \sqrt{15}} \over 34 } = 0.3197936 $ , \\ $ d =  { {13 - 3 \sqrt{15}} \over 34 } = 0.0406191 $ , 
 $e =  { {10 - 2 \sqrt{15}} \over 40 } = 0.0563508 $ , $ f =  { {10 + 2 \sqrt{15}} \over 40 } = 0.4436492 $

and  $\alpha = { {2665 + 14 \sqrt{15}} \over 226800 }$ , $ \beta = { {2665 - 14 \sqrt{15}} \over 226800 }$
 et   $\gamma = { 5 \over 567 } $

$\lambda_j$ for $j=1,4$ are barycentric coefficients for each vertex $S_j$ :

$b_k=\sum_{j=1,4}\lambda_j S_j$ for $k=1,15$

{\tt tetra10} surfaces are integrated using a 7 point rule

\begin{center}\begin{tabular}{|l|r|r|r|r|r|}
\hline
Points $b_k$    & $\lambda_1$   & $\lambda_2$   & $\lambda_3$  & weight $\omega_k$   \\ \hline   
1 & $c$ & $d$  & $c$& $\alpha$  \\ \hline 
2 & $d$ & $c$  & $c$& $\alpha$  \\ \hline 
3 & $c$ & $c$  & $d$& $\alpha$  \\ \hline 
4 & $b$ & $b$  & $a$& $\beta$   \\ \hline 
5 & $a$ & $b$  & $b$& $\beta$   \\ \hline   
6 & $b$ & $a$  & $b$& $\beta$   \\ \hline 
7 & ${ 1 \over 3 }$ & ${ 1 \over 3 }$ & ${1 \over 3 }$ & $\gamma$  \\ \hline  
\end{tabular} \end{center}

with $ \gamma = { 9 \over 80} = 0.11250 $ , $ \alpha = { {155 - \sqrt{15}} \over 2400 } = 0.06296959 $,  $ \beta = { {155 + \sqrt{15}} \over 2400 } = 0.066197075 $ and $ a =  {{9 - 2 \sqrt{15}} \over 21 } = 0.05961587 $ ,
      $ b =  { {6 + \sqrt{15}} \over 21 } = 0.47014206 $ ,
      $ c =  { {6 - \sqrt{15}} \over 21 } = 0.10128651 $ ,
      $ d =  {{9 + 2  \sqrt{15}} \over 21 } = 0.797427 $

$\lambda_j$ for $j=1,3$ are barycentric coefficients for each surface vertex $S_j$ :

$b_k=\sum_{j=1,3}\lambda_j S_j$ for $k=1,7$

\ruic{element}{q4p}{ (plane stress/strain)} %- - - - - - - - - - - - - - - - - - - - - -


The displacement (u,v) are bilinear functions over the element.

For surfaces, {\tt q4p} uses numerical integration at the corner nodes with $\omega_i=\frac{1}{4}$ and $b_i=S_i$ for $i=1,4$.

For edges, {\tt q4p} uses numerical integration at each corner node with $\omega_i=\frac{1}{2}$ and  $b_i=S_i$ for $i=1,2$.

\ruic{element}{q4p axisymmetric}{} % - - - - - - - - - - - - - - - - - - - - - - - - - -

For surfaces, {\tt q4p} uses a 4 point rule with 
\begin{itemize} 
 \item $\omega_i = {1 \over 4}$ for $i=1,4$
 \item $b_1 = (\alpha_1,\alpha_1)$ , $b_2 = (\alpha_2,\alpha_1)$ , $b_3 = (\alpha_2,\alpha_2)$ , 
      $b_4 = (\alpha_1,\alpha_2)$ \\ 
      with   $\alpha_1 = {1 \over 2} - { 1 \over {2 \sqrt{3}} } = 0.2113249 $ and
      $\alpha_2 = {1 \over 2} + { 1 \over {2 \sqrt{3}} } = 0.7886751 $
\end{itemize}

For edges, {\tt q4p} uses a 2 point rule with 
\begin{itemize} 
    \item $\omega_i = {1 \over 2}$ for $i=1,2$
    \item $b_1= \alpha_1$  and $b_2 = \alpha_2 $ the 2 gauss points of the edge.
\end{itemize}

\ruic{element}{q5p}{ (plane stress/strain)} % - - - - - - - - - - - - - - - - - - - - - - 

For surfaces, {\tt q5p} uses a 5 point rule with $b_i=S_i$ for $i=1,4$ the corner nodes and $b_5$ the node 5. 

For edges, {\tt q5p} uses a 1 point rule with $\omega = {1 \over 2}$ and  $b$  the midside node.

\ruic{element}{q8p}{ (plane stress/strain)} % - - - - - - - - - - - - - - - - - - - -

For surfaces, {\tt q8p} uses a 9 point rule with 
  \begin{itemize} 
     \item $\omega_k = w_i w_j$ for $i,j=1,3$ 
           with $w_1 = w_3 = \frac{5}{18} $ et $w_2 = \frac{8}{18} $
     \item $b_k =  (\alpha_i, \alpha_j) $ for $i,j=1,3$ 
%           with   $ \alpha_1 = { { 1 - \sqrt{3 \over 5} } \over 2 } $ ,
           with   $ \alpha_1 = { { 1 - \sqrt{\frac{3}{5}} } \over 2 } $ ,
           $ \alpha_2 = 0.5 $ and
%           $ \alpha_3 =  \frac{ 1 + \sqrt{3 \over 5 }} {2} $
           $ \alpha_3 =  \frac{ 1 + \sqrt{\frac{3}{5}}} {2} $
  \end{itemize}

For edges, {\tt q8p} uses a 3 point rule with 
 
  \begin{itemize} 
     \item $\omega_1 = \omega_2 = \frac{1}{6}$ and $ \omega_3 = \frac{4}{6} $
     \item $b_i=S_i$ for $i=1,2$ corner nodes of the edge et $b_3$ the midside.
  \end{itemize}

\ruic{element}{q8p axisymmetric}{} % - - - - - - - - - - - - - - - - - - - -


For surfaces, {\tt q8p} uses a 9 point rule with 
  \begin{itemize} 
    \item $\omega_k = w_i w_j$ for $i,j=1,3$  \\ with
         $w_1 = w_3 = \frac{5}{18} $ and $w_2 = \frac{8}{18} $
    \item $b_k =  (\alpha_i, \alpha_j) $ for $i,j=1,3$\\ with
          $ \alpha_1 = \frac{ 1 - \sqrt{\frac{3}{5}}}{2} $ , $ \alpha_2 = 0.5 $ 
          and $ \alpha_3 = \frac{ 1 + \sqrt{\frac{3}{5}}}{2} $
  \end{itemize}

For edges, {\tt q8p} uses a 3 point rule with 
  \begin{itemize} 
    \item $\omega_1 = \omega_3 =  \frac{5}{18}$ , $ \omega_2 =  \frac{8}{18} $
    \item $b_1 = \frac{ {1- \sqrt{\frac{3}{5}}  }} {2 } = 0.1127015 $, $ b_2 = 0.5 $
          and $b_3 = \frac{1 +  \sqrt{\frac{3}{5}}} {2} = 0.8872985 $  
  \end{itemize}

\ruic{element}{t3p}{ (plane stress/strain)} % - - - - - - - - - - - - - - - - - - - - - 


For surfaces, {\tt t3p} uses a 3 point rule at the vertices with $\omega_i = {1 \over 3}$ and $b_i=S_i$.

For edges,  {\tt t3p} uses a 2 point rule at the vertices with $\omega_i = {1 \over 2}$ and $b_i=S_i$.

\ruic{element}{t3p axisymmetric}{} % - - - - - - - - - - - - - - - - - - - - - 


For surfaces, {\tt t3p} uses a 1 point rule at the barycenter ($b_1=G$) with $\omega_1 = {1 \over 2}$  .

For edges,  {\tt t3p} uses a 2 point rule at the vertices with $\omega_i = {1 \over 2}$ and $b_1 = {1 \over 2} - { 2 \over {2 \sqrt{3}} } $ and $b_2 ={1 \over 2} + { 2 \over {2 \sqrt{3}} } $.

\ruic{element}{t6p}{ (plane stress/strain)} % - - - - - - - - - - - - - - - - - - - - 


For surfaces, {\tt t6p} uses a 3 point rule with 

  \begin{itemize} 
    \item $\omega_i = {1 \over 3}$ for $i=1,6$
    \item $b_{i} = S_{i+3,i+4}$ the three midside nodes.
  \end{itemize}

For edges,  {\tt t6p} uses a 3 point rule

  \begin{itemize} 
    \item $\omega_1 = \omega_2 = {1 \over 6}$ and $\omega_3 = {4 \over 6}$
    \item $b_i=S_i, i=1,2$  the  $i$-th vertex of the actual edge and
          $b_3 = S_{i,i+1}$ the midside.
   \end{itemize}

\ruic{element}{t6p axisymmetric}{} % - - - - - - - - - - - - - - - - - - - - 

For surfaces, {\tt t6p} uses a 7 point rule 
 \begin {center}
 \begin{large}
 \begin{tabular}{|l|r|r|r|c|}
  \hline
Points $b_k$ & $\lambda_1$   & $\lambda_2$   & $\lambda_3$  & weight $\omega_k$ \\
\hline                                             
1           & ${ 1 \over 3 }$ & ${ 1 \over 3 }$ & ${1 \over 3 }$ & $a$         \\
\hline  
2           & $\alpha$      & $\beta$         & $\beta$        & $b$ \\
\hline                                           
3           & $\beta$       & $\beta$         & $\alpha$       & $b$ \\
\hline                                           
4           & $\beta$       & $\alpha$        & $\beta$        & $b$ \\
\hline                                           
5           & $\gamma$      & $\gamma$        & $\delta$       & $c$ \\
\hline                                           
6           & $\delta$      & $\gamma$        & $\gamma$       & $c$ \\
\hline                                           
7           & $\gamma$      & $\delta$        & $\gamma$       & $c$ \\
\hline                                           
\end{tabular} 
\end{large}
\end{center}
with : \par
      \begin{large}
%       $ a = { 9 \over 80} = 0.11250 $ ,  
%       $ b = { {155 + \sqrt{15}} \over 2400 } = 0.066197075 $ and \\
%       $ c = { {155 - \sqrt{15}} \over 2400 } = 0.06296959 $
       $ a = \frac{ 9 }{ 80} = 0.11250 $ ,  
       $ b = \frac {155 + \sqrt{15}} {2400 } = 0.066197075 $ and \\
       $ c = \frac {155 - \sqrt{15}} {2400 } = 0.06296959 $
      \end{large}

%     $ \alpha =  {{9 - 2 \sqrt{15}} \over 21 } = 0.05961587 $ ,
     $ \alpha =  \frac{9 - 2 \sqrt{15}} { 21 } = 0.05961587 $ ,
      \begin{large}
%       $ \beta =  { {6 + \sqrt{15}} \over 21 } = 0.47014206 $  \\
%       $\gamma =  { {6 - \sqrt{15}} \over 21 } = 0.10128651 $ , 
%       $ \delta =  {{9 + 2  \sqrt{15}} \over 21 } = 0.797427 $
       $ \beta =  \frac {6 + \sqrt{15}} { 21 } = 0.47014206 $  \\
       $\gamma =  \frac {6 - \sqrt{15}} { 21 } = 0.10128651 $ , 
       $ \delta = \frac {9 + 2  \sqrt{15}}  { 21 } = 0.797427 $
      \end{large}

$\lambda_j$ for $j=1,3$ are barycentric coefficients for each vertex $S_j$ :

$b_k=\sum_{j=1,3}\lambda_j S_j$ for $k=1,7$


For edges,  {\tt t6p} uses a 3 point rule with
%$\omega_1 = \omega_3 = { 5 \over 18}$ , $ \omega_2 = { 8 \over 18 } $
$\omega_1 = \omega_3 = \frac{5}{18}$ , $ \omega_2 =  \frac{8}{18}$

%$b_1 = { {1- \sqrt{ 3 \over 5 }  } \over 2 } = 0.1127015 $, $ b_2 = 0.5 $ and   
%            $b_3 = { {1 +  \sqrt{ 3 \over 5 }  } \over 2 } = 0.8872985 $ 
$b_1 = \frac{1- \sqrt{\frac{3}{5}}}  {2 } = 0.1127015 $, $ b_2 = 0.5 $ and   
            $b_3 = \frac {1 +  \sqrt{ \frac{3}{5}  }} { 2 } = 0.8872985 $ 



















